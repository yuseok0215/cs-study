# 1-1 쿠키와 세션의 차이에 대해 설명해 주세요.
  쿠키는 클라이언트 측에 저장되는 데이터이고, 세션은 서버 측에 저장되는 사용자 상태 정보입니다. 쿠키는 클라이언트가 가지고 있기 때문에 위변조의 위험이 있고, 민감한 정보를 저장하기엔 부적절합니다. 반면, 세션은 서버에서 관리하기 때문에 보안상 더 안전하게 상태를 유지할 수 있습니다.

1-2 세션 방식의 로그인 과정에 대해 설명해 주세요.
  세션 기반 로그인은 사용자가 ID와 비밀번호로 로그인 요청을 하면, 서버는 인증 후 세션을 생성하고 고유한 세션 ID를 발급합니다. 이 ID는 클라이언트에 쿠키로 전달되고, 클라이언트는 이후 요청마다 이 세션 ID를 함께 전송합니다. 서버는 이 세션 ID를 기반으로 로그인된 사용자의 정보를 유지합니다.

1-3 HTTP의 특성인 Stateless에 대해 설명해 주세요.
  HTTP는 Stateless 프로토콜로, 요청 간의 상태를 서버가 유지하지 않습니다. 즉, 매 요청은 독립적이며 서버는 이전 요청의 정보를 기억하지 않습니다. 이 특성 덕분에 서버의 확장성과 단순성이 확보되지만, 로그인 같은 상태 유지가 필요한 경우에는 세션이나 토큰 기반 인증 방식이 추가로 필요합니다.

1-4 Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?
   Stateless의 관점에서 보면 세션은 서버가 상태를 기억하기 때문에 엄밀히 말하면 Stateless와 맞지 않는 방식입니다. 하지만 실무에서는 인증 상태 유지를 위해 세션이 많이 사용됩니다. 완전한 Stateless 환경을 원할 경우에는 JWT와 같은 토큰 기반 인증을 도입해 서버가 상태 정보를 기억하지 않고도 인증을 유지할 수 있습니다.

1-5 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?
서버가 여러 대일 경우, 세션을 서버 내부에 저장하면 로드밸런싱 시 문제가 생깁니다. 이를 해결하기 위해 Sticky Session을 사용하거나, Redis와 같은 외부 세션 저장소를 통해 모든 서버에서 동일한 세션 데이터를 공유하도록 구성할 수 있습니다. 또는 JWT 기반 토큰 인증을 사용하면 세션 자체가 필요 없기 때문에 Stateless 구조로 확장성이 좋아집니다.

---

# 2.1 HTTP 응답코드에 대해 설명해 주세요.
HTTP 응답 코드는 서버가 클라이언트 요청에 대해 어떤 처리를 했는지를 나타내는 숫자입니다.
클라이언트와 서버 간의 상태를 명확하게 표현함으로써, API의 명세를 더 직관적으로 만들 수 있습니다.

크게 5가지 범위로 나뉘며, 각 범위는 다음과 같습니다
- **1xx**: 정보 전달 (Processing 중 등)
- **2xx**: 성공 (200 OK, 201 Created 등)
- **3xx**: 리다이렉션 (301, 302)
- **4xx**: 클라이언트 오류 (400 Bad Request, 404 Not Found 등)
- **5xx**: 서버 오류 (500 Internal Server Error 등)

2.2 401 (Unauthorized) 와 403 (Forbidden)의 차이는?
401과 403은 모두 인증 및 인가와 관련된 클라이언트 오류 상태를 나타냅니다.

- **401 Unauthorized**는 **인증이 필요하거나 인증에 실패한 경우**에 사용됩니다. 예를 들어, 토큰이 없거나 만료된 경우입니다.
- 반면에 **403 Forbidden**은 **인증은 되었지만 요청한 리소스에 대한 권한이 없을 때** 사용됩니다. 예를 들어, 일반 사용자가 관리자 전용 기능을 요청했을 때입니다.

정리하면 401은 로그인 자체가 안 된 상태, 403은 로그인은 되었지만 권한이 없을 때 발생합니다

2.3 200 (OK) 와 201 (Created)의 차이점은?
둘 다 성공 응답이지만 의미가 다릅니다.

- **200 OK**는 요청이 정상적으로 처리되었을 때 사용하는 일반적인 성공 응답입니다. 주로 GET, PUT, PATCH 요청의 응답으로 사용됩니다.
- **201 Created**는 **POST 요청으로 새로운 리소스가 생성된 경우**에 사용합니다. 생성된 리소스의 URI를 `Location` 헤더에 포함하기도 합니다.

예를 들어, 회원가입 API에서 사용자를 새로 만들었다면 201 응답을 반환하는 것이 REST 관점에서 더 적절합니다.

2.4 직접 응답코드를 정의해서 사용할 수 있나요? (예: 285번)
가능하지만, 비표준 응답 코드는 권장되지 않습니다.

HTTP 클라이언트, 브라우저, 프록시, 로드밸런서 등 대부분의 네트워크 구성 요소는 **RFC 표준에 정의된 100~599 사이의 응답코드**만 정상적으로 해석합니다.

285 같은 응답 코드를 정의하면 일부 클라이언트에서 예외를 발생시키거나 응답을 해석하지 못할 수 있습니다.

대신, **표준 범위 내에서 의미에 맞는 코드(예: 2xx, 4xx 등)를 선택하고**, 필요한 경우 응답 body나 커스텀 헤더에 추가 정보를 담는 방식이 실무에서는 더 안전하고 호환성이 좋습니다.

---

# 3.1 HTTP Method에 대해 설명해 주세요.
HTTP Method는 클라이언트가 서버에 어떤 작업을 요청하는지를 명확하게 표현하는 방식입니다.

주요 메서드는 다음과 같습니다:

- **GET**: 리소스 조회 (읽기 전용)
- **POST**: 리소스 생성
- **PUT**: 리소스 전체 수정
- **PATCH**: 리소스 부분 수정
- **DELETE**: 리소스 삭제

RESTful API 설계에서는 자원 중심으로 URI를 정의하고, 작업의 의미를 HTTP 메서드로 구분하는 것이 중요합니다.

3.2 HTTP Method의 멱등성에 대해 설명해 주세요.
멱등성(idempotent)이란, 같은 요청을 여러 번 보내도 결과가 같아야 한다는 의미입니다.

- **GET, PUT, DELETE**는 멱등한 메서드입니다. 예를 들어 같은 데이터를 PUT 여러 번 해도 결과는 동일합니다.
- **POST, PATCH**는 멱등하지 않습니다. POST는 호출할 때마다 리소스가 새로 생성될 수 있고, PATCH는 데이터에 따라 매번 다르게 반영될 수 있습니다.

멱등성은 API 재시도 시 서버의 부작용을 방지하는 데 중요한 개념입니다.

3.3 GET과 POST의 차이는 무엇인가요?
GET은 주로 데이터 조회에 사용되며, 안전하고 멱등한 메서드입니다. 브라우저 캐싱, 프록시, 즐겨찾기 등에서도 자연스럽게 활용됩니다.
POST는 **서버 상태를 변경**하는 작업에 사용되며, **멱등하지 않고 캐싱도 되지 않습니다**.
예를 들어 상품 상세 조회는 GET, 회원가입이나 결제 요청은 POST로 처리합니다.

3.4 POST와 PUT, PATCH의 차이는 무엇인가요?
- POST는 새로운 리소스를 생성할 때 사용합니다. 같은 요청을 여러 번 보내면 여러 개가 생성될 수 있어 멱등하지 않습니다.
- PUT은 전체 리소스를 **덮어쓰기(전체 수정)**합니다. 요청에 포함되지 않은 필드는 제거될 수 있으며, 멱등합니다.
- PATCH는 일부 필드만 수정할 때 사용하며, 보통 멱등하지 않습니다.

3.5 HTTP 1.1 이후로 GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?
HTTP/1.1 사양상으로는 GET 요청에도 Body를 실을 수는 있습니다. 하지만 RFC에서도 이를 명확하게 정의하지 않고, 대부분의 브라우저, 프록시, 캐시 서버 등이 GET의 Body를 무시하거나 예외를 발생시킵니다.

특히 캐싱/리다이렉션/프록시 서버들은 GET 요청은 Body가 없다는 전제로 동작하므로, 이 방식은 **호환성과 예측 가능성 측면에서 문제가 많습니다**.

그래서 실무에서는 GET에는 Query Parameter를 사용하고, Body가 필요한 복잡한 요청은 POST나 다른 메서드로 처리하는 것이 일반적입니다.

---

# 4.1 HTTP에 대해 설명해 주세요.
HTTP는 HyperText Transfer Protocol의 약자로, 클라이언트와 서버 간에 데이터를 주고받기 위한 비연결형(Stateless) 프로토콜입니다.
주로 웹 브라우저와 웹 서버 간의 통신에 사용되며, 기본적으로 텍스트 기반이며 TCP 위에서 동작합니다.
HTTP는 전송 시 암호화를 제공하지 않기 때문에 **중간자 공격(MITM)**에 취약합니다. 그래서 HTTPS를 통해 보안성을 강화합니다.

**4.2 공개키와 대칭키에 대해 설명해 주세요.**
암호화에는 크게 대칭키 방식과 공개키(비대칭키) 방식이 있습니다.

- **대칭키 방식**은 암호화와 복호화에 **같은 키**를 사용하며, 속도가 빠릅니다. 하지만 키를 안전하게 공유하는 것이 어렵습니다.
- **공개키 방식**은 **암호화에는 공개키**, **복호화에는 개인키**를 사용하는 구조이며, 키 전달은 안전하지만 연산 속도가 느립니다.

그래서 실무에서는 두 방식을 혼합하여 사용하는데, HTTPS에서도 이 구조를 따릅니다.

**4.3 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것일까요?**
HTTPS는 보안이 적용된 HTTP로, TLS(또는 SSL) 프로토콜 위에서 동작합니다.

클라이언트가 서버에 최초로 접속할 때, **서버는 인증서를 통해 자신의 신원을 증명**합니다. 이 인증서에는 **서버의 공개키**와 **공인된 인증 기관(CA)의 서명**이 포함되어 있습니다.

클라이언트는 이 인증서를 검증하고, 이후에 안전하게 대칭키를 교환하여 본격적인 암호화 통신을 시작합니다.

즉, **공개키 기반 인증서로 신뢰성을 보장하고**, 그 후에 **대칭키를 이용해 빠르게 암호화 통신**을 합니다.

**4.4 SSL과 TLS의 차이는 무엇인가요?**
SSL과 TLS는 모두 암호화 통신을 위한 프로토콜입니다.

- **SSL(Secure Sockets Layer)**은 초기 버전의 보안 프로토콜이고,
- **TLS(Transport Layer Security)**는 SSL의 후속 프로토콜로, **더 강력한 암호화 알고리즘과 보안 기능**을 제공합니다.

현재는 SSL 2.0/3.0은 모두 보안상 폐기되었고, 대부분 TLS 1.2 또는 TLS 1.3을 사용합니다.

실무에서 말하는 "SSL 인증서"도 실제로는 TLS 기반에서 사용됩니다.

---

# 5.1 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.
**웹소켓은** HTTP 기반의 프로토콜 업그레이드 방식으로, 브라우저와 서버 간에 양방향 통신을 가능하게 하는 기술입니다.

반면 **소켓 통신**은 **TCP/UDP 기반의 일반적인 네트워크 통신 방식**으로, 브라우저가 아닌 로우레벨 클라이언트 프로그램에서 주로 사용됩니다.

웹소켓은 초기에는 HTTP를 통해 연결을 시작하지만, 연결이 수립되면 그 이후에는 **지속적인 연결 상태를 유지하며** 실시간 데이터를 주고받습니다.

소켓 통신은 이보다 더 범용적이며, HTTP 없이도 TCP/IP만으로 연결을 수립해 데이터를 교환할 수 있습니다. 따라서 **웹소켓은 소켓 통신의 특수한 형태**라고 볼 수 있습니다.

5.2 소켓과 포트의 차이가 무엇인가요?
**포트**는 IP 주소 내에서 여러 네트워크 애플리케이션을 구분하기 위한 번호입니다. 하나의 서버 IP에서 여러 서비스를 운영할 수 있는 이유가 바로 포트 때문입니다.

반면 **소켓**은 **통신 연결을 위한 개념적인 종단점**으로, 일반적으로 "IP 주소 + 포트 번호"로 정의됩니다.

예를 들어, 클라이언트가 서버의 80번 포트로 접속하면, **클라이언트 소켓 ↔ 서버 소켓 간의 연결이 생성**되는 것입니다.

즉, 포트는 **주소**의 일부이고, 소켓은 **연결 단위의 객체**라고 이해하면 됩니다.

5.3 여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?
서버 입장에서 보면 여러 소켓이 같은 포트를 공유할 수 있습니다. 예를 들어, 웹 서버는 **80번 포트 하나를 리슨(listen)**하고 있지만, 다수의 클라이언트가 접속하면 각각의 클라이언트에 대해 개별 소켓 객체가 생성됩니다.

이 소켓들은 내부적으로는 **서버의 IP:포트 ↔ 클라이언트의 IP:포트** 조합으로 구분됩니다.

즉, **서버 측 포트는 동일할 수 있고**, 클라이언트의 포트는 매 연결마다 동적으로 할당되기 때문에 **모두 다를 수 있습니다**.

5.4 사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?
네, 클라이언트와 서버 간의 TCP 연결이 하나 생기면, 서버는 해당 연결을 처리하기 위해 소켓 객체를 생성합니다. 그래서 동시 접속자가 많아질수록 소켓 수도 함께 증가합니다.

하지만 모든 요청이 새로운 소켓을 만드는 건 아닙니다. 예를 들어 일반적인 HTTP 요청은 **요청-응답 후 소켓을 바로 닫는 단발성 통신**이고,

웹소켓이나 TCP 기반 실시간 시스템처럼 연결을 유지하는 방식은 **소켓을 장시간 유지**합니다.

소켓이 너무 많아지면 **리소스 고갈(파일 디스크립터, 메모리, 스레드 등)** 문제가 발생할 수 있으므로, **커넥션 풀링, Keep-Alive 설정, 타임아웃 제어** 등으로 관리합니다.

---

# 6.1 HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?
HTTP/1.1은 기본적으로 요청-응답을 하나씩 처리하는 구조입니다. 연결은 Keep-Alive를 통해 유지되지만, 동시에 여러 요청을 처리할 수 없는 구조라 **지연(Latency)**이 발생합니다.

HTTP/2는 이런 단점을 해결하기 위해 나온 프로토콜로, 가장 큰 차이는 **멀티플렉싱(Multiplexing)**입니다.

하나의 TCP 연결에서 여러 개의 요청과 응답을 동시에 주고받을 수 있어 성능이 대폭 개선됩니다.

그 외에도 **헤더 압축(HPACK)**, 서버 푸시 기능 등이 추가되어 전체적인 네트워크 효율이 좋아졌습니다.

6.2 HOL(Head-of-Line) Blocking에 대해 설명해 주세요.
HOL Blocking은 선두 지연 현상을 말합니다.

예를 들어 하나의 요청이 TCP 전송 중 지연되거나 패킷 손실이 발생하면, **같은 연결 안의 다른 요청들도 응답을 기다리며 함께 지연되는 문제**가 생깁니다.

HTTP/2에서도 멀티플렉싱이 있긴 하지만 **기반은 여전히 TCP이기 때문에**, 하나의 패킷 손실로 인해 전체 연결 지연이 발생하는 **전송 계층 차원의 HOL Blocking**은 완전히 해결되지 않았습니다.

6.3 HTTP/3.0의 주요 특징에 대해 설명해 주세요.
HTTP/3는 기존 HTTP/2와 다르게 TCP가 아닌 UDP 위에서 동작합니다.

**QUIC 프로토콜**이라는 전송 계층을 사용하며, **HOL Blocking 문제를 근본적으로 해결**한 것이 가장 큰 특징입니다.

QUIC은 패킷 손실이 발생해도 다른 스트림에 영향을 주지 않고, **연결 수립이 빠르고, TLS 암호화를 전송 계층에 내장**하고 있어 성능과 보안 모두 향상됐습니다.

특히 모바일 환경이나 무선 네트워크처럼 **손실률이 높은 환경에서 장점을 크게 발휘**합니다.

현재는 크롬, 유튜브, 클라우드플레어 등에서 실서비스로 널리 사용되고 있습니다.



