# 1-1 쿠키와 세션의 차이에 대해 설명해 주세요.
  쿠키는 클라이언트 측에 저장되는 데이터이고, 세션은 서버 측에 저장되는 사용자 상태 정보입니다. 쿠키는 클라이언트가 가지고 있기 때문에 위변조의 위험이 있고, 민감한 정보를 저장하기엔 부적절합니다. 반면, 세션은 서버에서 관리하기 때문에 보안상 더 안전하게 상태를 유지할 수 있습니다.

1-2 세션 방식의 로그인 과정에 대해 설명해 주세요.
  세션 기반 로그인은 사용자가 ID와 비밀번호로 로그인 요청을 하면, 서버는 인증 후 세션을 생성하고 고유한 세션 ID를 발급합니다. 이 ID는 클라이언트에 쿠키로 전달되고, 클라이언트는 이후 요청마다 이 세션 ID를 함께 전송합니다. 서버는 이 세션 ID를 기반으로 로그인된 사용자의 정보를 유지합니다.

1-3 HTTP의 특성인 Stateless에 대해 설명해 주세요.
  HTTP는 Stateless 프로토콜로, 요청 간의 상태를 서버가 유지하지 않습니다. 즉, 매 요청은 독립적이며 서버는 이전 요청의 정보를 기억하지 않습니다. 이 특성 덕분에 서버의 확장성과 단순성이 확보되지만, 로그인 같은 상태 유지가 필요한 경우에는 세션이나 토큰 기반 인증 방식이 추가로 필요합니다.

1-4 Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?
   Stateless의 관점에서 보면 세션은 서버가 상태를 기억하기 때문에 엄밀히 말하면 Stateless와 맞지 않는 방식입니다. 하지만 실무에서는 인증 상태 유지를 위해 세션이 많이 사용됩니다. 완전한 Stateless 환경을 원할 경우에는 JWT와 같은 토큰 기반 인증을 도입해 서버가 상태 정보를 기억하지 않고도 인증을 유지할 수 있습니다.

1-5 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?
서버가 여러 대일 경우, 세션을 서버 내부에 저장하면 로드밸런싱 시 문제가 생깁니다. 이를 해결하기 위해 Sticky Session을 사용하거나, Redis와 같은 외부 세션 저장소를 통해 모든 서버에서 동일한 세션 데이터를 공유하도록 구성할 수 있습니다. 또는 JWT 기반 토큰 인증을 사용하면 세션 자체가 필요 없기 때문에 Stateless 구조로 확장성이 좋아집니다.

---

# 2.1 HTTP 응답코드에 대해 설명해 주세요.
HTTP 응답 코드는 서버가 클라이언트 요청에 대해 어떤 처리를 했는지를 나타내는 숫자입니다.
클라이언트와 서버 간의 상태를 명확하게 표현함으로써, API의 명세를 더 직관적으로 만들 수 있습니다.

크게 5가지 범위로 나뉘며, 각 범위는 다음과 같습니다
- **1xx**: 정보 전달 (Processing 중 등)
- **2xx**: 성공 (200 OK, 201 Created 등)
- **3xx**: 리다이렉션 (301, 302)
- **4xx**: 클라이언트 오류 (400 Bad Request, 404 Not Found 등)
- **5xx**: 서버 오류 (500 Internal Server Error 등)

2.2 401 (Unauthorized) 와 403 (Forbidden)의 차이는?
401과 403은 모두 인증 및 인가와 관련된 클라이언트 오류 상태를 나타냅니다.

- **401 Unauthorized**는 **인증이 필요하거나 인증에 실패한 경우**에 사용됩니다. 예를 들어, 토큰이 없거나 만료된 경우입니다.
- 반면에 **403 Forbidden**은 **인증은 되었지만 요청한 리소스에 대한 권한이 없을 때** 사용됩니다. 예를 들어, 일반 사용자가 관리자 전용 기능을 요청했을 때입니다.

정리하면 401은 로그인 자체가 안 된 상태, 403은 로그인은 되었지만 권한이 없을 때 발생합니다

2.3 200 (OK) 와 201 (Created)의 차이점은?
둘 다 성공 응답이지만 의미가 다릅니다.

- **200 OK**는 요청이 정상적으로 처리되었을 때 사용하는 일반적인 성공 응답입니다. 주로 GET, PUT, PATCH 요청의 응답으로 사용됩니다.
- **201 Created**는 **POST 요청으로 새로운 리소스가 생성된 경우**에 사용합니다. 생성된 리소스의 URI를 `Location` 헤더에 포함하기도 합니다.

예를 들어, 회원가입 API에서 사용자를 새로 만들었다면 201 응답을 반환하는 것이 REST 관점에서 더 적절합니다.

2.4 직접 응답코드를 정의해서 사용할 수 있나요? (예: 285번)
가능하지만, 비표준 응답 코드는 권장되지 않습니다.

HTTP 클라이언트, 브라우저, 프록시, 로드밸런서 등 대부분의 네트워크 구성 요소는 **RFC 표준에 정의된 100~599 사이의 응답코드**만 정상적으로 해석합니다.

285 같은 응답 코드를 정의하면 일부 클라이언트에서 예외를 발생시키거나 응답을 해석하지 못할 수 있습니다.

대신, **표준 범위 내에서 의미에 맞는 코드(예: 2xx, 4xx 등)를 선택하고**, 필요한 경우 응답 body나 커스텀 헤더에 추가 정보를 담는 방식이 실무에서는 더 안전하고 호환성이 좋습니다.

---

# 3.1 HTTP Method에 대해 설명해 주세요.
HTTP Method는 클라이언트가 서버에 어떤 작업을 요청하는지를 명확하게 표현하는 방식입니다.

주요 메서드는 다음과 같습니다:

- **GET**: 리소스 조회 (읽기 전용)
- **POST**: 리소스 생성
- **PUT**: 리소스 전체 수정
- **PATCH**: 리소스 부분 수정
- **DELETE**: 리소스 삭제

RESTful API 설계에서는 자원 중심으로 URI를 정의하고, 작업의 의미를 HTTP 메서드로 구분하는 것이 중요합니다.

3.2 HTTP Method의 멱등성에 대해 설명해 주세요.
멱등성(idempotent)이란, 같은 요청을 여러 번 보내도 결과가 같아야 한다는 의미입니다.

- **GET, PUT, DELETE**는 멱등한 메서드입니다. 예를 들어 같은 데이터를 PUT 여러 번 해도 결과는 동일합니다.
- **POST, PATCH**는 멱등하지 않습니다. POST는 호출할 때마다 리소스가 새로 생성될 수 있고, PATCH는 데이터에 따라 매번 다르게 반영될 수 있습니다.

멱등성은 API 재시도 시 서버의 부작용을 방지하는 데 중요한 개념입니다.

3.3 GET과 POST의 차이는 무엇인가요?
GET은 주로 데이터 조회에 사용되며, 안전하고 멱등한 메서드입니다. 브라우저 캐싱, 프록시, 즐겨찾기 등에서도 자연스럽게 활용됩니다.
POST는 **서버 상태를 변경**하는 작업에 사용되며, **멱등하지 않고 캐싱도 되지 않습니다**.
예를 들어 상품 상세 조회는 GET, 회원가입이나 결제 요청은 POST로 처리합니다.

3.4 POST와 PUT, PATCH의 차이는 무엇인가요?
- POST는 새로운 리소스를 생성할 때 사용합니다. 같은 요청을 여러 번 보내면 여러 개가 생성될 수 있어 멱등하지 않습니다.
- PUT은 전체 리소스를 **덮어쓰기(전체 수정)**합니다. 요청에 포함되지 않은 필드는 제거될 수 있으며, 멱등합니다.
- PATCH는 일부 필드만 수정할 때 사용하며, 보통 멱등하지 않습니다.

3.5 HTTP 1.1 이후로 GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?
HTTP/1.1 사양상으로는 GET 요청에도 Body를 실을 수는 있습니다. 하지만 RFC에서도 이를 명확하게 정의하지 않고, 대부분의 브라우저, 프록시, 캐시 서버 등이 GET의 Body를 무시하거나 예외를 발생시킵니다.

특히 캐싱/리다이렉션/프록시 서버들은 GET 요청은 Body가 없다는 전제로 동작하므로, 이 방식은 **호환성과 예측 가능성 측면에서 문제가 많습니다**.

그래서 실무에서는 GET에는 Query Parameter를 사용하고, Body가 필요한 복잡한 요청은 POST나 다른 메서드로 처리하는 것이 일반적입니다.

---

# 4.1 HTTP에 대해 설명해 주세요.
HTTP는 HyperText Transfer Protocol의 약자로, 클라이언트와 서버 간에 데이터를 주고받기 위한 비연결형(Stateless) 프로토콜입니다.
주로 웹 브라우저와 웹 서버 간의 통신에 사용되며, 기본적으로 텍스트 기반이며 TCP 위에서 동작합니다.
HTTP는 전송 시 암호화를 제공하지 않기 때문에 **중간자 공격(MITM)**에 취약합니다. 그래서 HTTPS를 통해 보안성을 강화합니다.

**4.2 공개키와 대칭키에 대해 설명해 주세요.**
암호화에는 크게 대칭키 방식과 공개키(비대칭키) 방식이 있습니다.

- **대칭키 방식**은 암호화와 복호화에 **같은 키**를 사용하며, 속도가 빠릅니다. 하지만 키를 안전하게 공유하는 것이 어렵습니다.
- **공개키 방식**은 **암호화에는 공개키**, **복호화에는 개인키**를 사용하는 구조이며, 키 전달은 안전하지만 연산 속도가 느립니다.

그래서 실무에서는 두 방식을 혼합하여 사용하는데, HTTPS에서도 이 구조를 따릅니다.

**4.3 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것일까요?**
HTTPS는 보안이 적용된 HTTP로, TLS(또는 SSL) 프로토콜 위에서 동작합니다.

클라이언트가 서버에 최초로 접속할 때, **서버는 인증서를 통해 자신의 신원을 증명**합니다. 이 인증서에는 **서버의 공개키**와 **공인된 인증 기관(CA)의 서명**이 포함되어 있습니다.

클라이언트는 이 인증서를 검증하고, 이후에 안전하게 대칭키를 교환하여 본격적인 암호화 통신을 시작합니다.

즉, **공개키 기반 인증서로 신뢰성을 보장하고**, 그 후에 **대칭키를 이용해 빠르게 암호화 통신**을 합니다.

**4.4 SSL과 TLS의 차이는 무엇인가요?**
SSL과 TLS는 모두 암호화 통신을 위한 프로토콜입니다.

- **SSL(Secure Sockets Layer)**은 초기 버전의 보안 프로토콜이고,
- **TLS(Transport Layer Security)**는 SSL의 후속 프로토콜로, **더 강력한 암호화 알고리즘과 보안 기능**을 제공합니다.

현재는 SSL 2.0/3.0은 모두 보안상 폐기되었고, 대부분 TLS 1.2 또는 TLS 1.3을 사용합니다.

실무에서 말하는 "SSL 인증서"도 실제로는 TLS 기반에서 사용됩니다.

