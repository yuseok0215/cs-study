### 🔍 1. JVM이란 무엇인가요?
JVM(Java Virtual Machine)은 바이트 코드를 실행하는 가상 머신입니다. 운영체제와 상관없이 자바 코드를 어디에서나 실행할 수 있게 해주며, 가비지 컬렉터를 사용해 자동으로 메모리 관리가 가능합니다.

#### ❓ 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?
자바 말고 다른 언어도 JVM에 올릴 수 있습니다. 바이트 코드로 컴파일되는 언어는 모두 JVM 위에서 실행 가능합니다. 대표적으로 코틀린, 스칼라, 그루비, 클로저 등이 있습니다.

#### ❓ 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?
없습니다. 보통 JVM 계열 언어는 JVM 위에서 실행되도록 설계되었기 때문입니다. 하지만 코틀린의 경우 Kotlin/Native를 통해 JVM 없이도 실행 가능한 네이티브 바이너리로 컴파일할 수 있습니다.

#### ❓ VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.
장점은 운영체제 영향을 받지 않는다. spring등과 같은 풍부한 생태계가 있다. 메모리와 스레드를 JVM이 자동으로 처리합니다.
단점은 JVM 자체 메모리 부담이 존재하고, 시작 속도가 느립니다.


#### ❓ JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?
아닙니다. JVM은 독립적인 프로세스이고 내부에서 실행되고 있는 프로그램은 JVM 내부의 스레드로 실행됩니다. 따라서 JVM과 자바 프로그램은 동일 프로세스 내에서 동작하는 관계입니다.

---
### 🔍 2. final 키워드를 사용하면, 어떤 이점이 있나요? 
불변성이 보장되기 때문에 코드 안정성이 증가됩니다. 또한 값이 변경되지 않음을 보장하므로 코드를 예측하기 쉬워집니다. 

#### ❓그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?
final 키워드가 붙은 변수의 경우 변수를 호출하는 대신 실제 값을 호출하기 때문에 성능 향상에 도움이 됩니다.

---

### 🔍 3. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.
추상 클래스는 공통된 상태와 기능을 가진 클래스가 많을 경우 코드 재사용성을 높이기 위해 사용하고, 인터페이스는 클래스들이 동일한 동작을 보장해야 할 때 사용합니다. 또한, 추상 클래스는 단일 상속만 가능하지만 인터페이스는 다중 구현이 가능하기 때문에, 유연한 설계나 확장성을 원할 경우 인터페이스가 적합합니다.

#### ❓ 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?
클래스를 다중 상속할 경우 여러 부모 클래스에 이름이 같은 메서드가 존재할 수 있습니다. 이때 어떤 클래스의 메서드를 호출해야 하는지 판단하기 어렵습니다. 즉, 다이아몬드 문제가 발생합니다. 인터페이스는 매서드에 대한 구현이 없고 선언만 존재하기 대문에 충돌이 일어날 가능성이 없어 2개 이상 구현이 가능합니다.

---

### 🔍 4. 리플렉션에 대해 설명해 주세요.
리플렉션은 클래스로더를 통해 읽어온 클래스 정보를 사용하는 기술입니다. 클래스 이름만 알고 있어도 리플렉션을 사용해 클래스 읽어오거나, 인스턴스를 읽어오거나, 필드의 값을 변경하는 것도 가능합니다.

#### ❓  의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?
setAccessible(true) 접근 제어를 무시할 수도 있고, 코드 인젝션 위험도 있어 보안적인 문제가 존재합니다. 따라서 어떤 클래스가 올지 모르는 동적인 상황을 제외하고서는 사용을 지양하는 것이 좋습니다. 

#### ❓ 리플렉션을 언제 활용할 수 있을까요?
특정 어노테이션이 붙어있는 필드나 메서드를 읽어오거나, 특정 네이밍 패턴에 해당하는 메서드나 필드가 필요한 경우 활용할 수 있습니다.

--- 
### 🔍 5.static class와 static method를 비교해 주세요.
static class는 중첩 클래스에서 사용하는 개념입니다. 외부 클래스 객체 없이 사용 가능하고 내부 클래스지만 독립적으로 동작해야할 때 사용합니다. static method는 클래스 내부의 정적 메서드입니다. 인스턴스 없이 클래스명으로만 호출 가능합니다. 유틸리티 함수와 같이 객체 생성 없이 호출하는 함수를 구현할 때 유용합니다.

#### ❓ static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?
모든 객체가 공유할 수 있다. 객체 생성 없이 접근 가능하기 때문에 빠르게 호출이 가능합니다.
인스턴스 멤버에 접근 할 수 없습니다. static 영역 내에서는 static만 접근 가능하다. this 키워드 사용 불가능하다. 오버라이딩도 불 가능해서 다형성 적용이 어렵습니다.

#### ❓ 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.
인스턴스와 무관하게 JVM이 클래스 로딩 시점에 메모리에 올려 메서드 영역에 저장됩니다. 

--- 
### 🔍 6. Java의 Exception에 대해 설명해 주세요.
Exception은 프로그램 실행 중에 발생할 수 있는 예외 상황을 객체로 표현한 것입니다. 예외 처리를 통해 프로그램이 비정상적으로 종료되지 않도록 제어할 수 있습니다. 최상위 예외 계층인 Throwable 클래스 기준으로 Error와 Exception으로 구분된다. 일반적으로 개발자가 처리하는 예외는 Exception입니다.

#### ❓ 예외처리를 하는 세 방법에 대해 설명해 주세요.
예외 복구는 예외를 try-catch 블록으로 직접 잡아서 처리하는 방법입니다. 예외 발생 시에도 프로그램이 계속 실행될 수 있습니다. 예외 처리 회피는 메서드에 throws를 선언해서 호출한 쪽에서 예외 처리를 하도록 위임하는 방법입니다. 예외 전환은 발생한 예외를 구체적이고 의미있는 예외로 변환해서 던지는 방법입니다.

#### ❓ CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.
CheckedException은 Exception 클래스 중 RuntimeException을 제외한 예외들입니다. 컴파일 시점에 반드시 예외를 처리하도록 강제합니다.  UncheckedException RuntimeException 및 그 하위 클래스입니다. 컴파일 시점에 발견되지 않고 런타임에서 발생합니다.

#### ❓ 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?
예외가 발생하면 JVM은 예외 객체를 생성하면서 stack trace 수집해서 객체에 저장합니다. 이 과정은 단순 메모리 할당보다 무겁기 때문에 성능에 영향을 줄 수 있습니다. stack trace를 제거한 커스텀 예외로 전환해서 부하를 줄이거나 예외 발생 전에 조건을 미리 점검해서 예외 발생 자체를 줄이는 방법이 있습니다. 예외는 꼭 필요한 상황에 사용해야하며 자주 발생하는 상황이라면 예외가 아닌 정상 흐름으로 처리할 수 있도록 설계하는게 좋습니다. 
