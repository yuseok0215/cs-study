### 🔍 1. JVM이란 무엇인가요?
JVM(Java Virtual Machine)은 바이트 코드를 실행하는 가상 머신입니다. 운영체제와 상관없이 자바 코드를 어디에서나 실행할 수 있게 해주며, 가비지 컬렉터를 사용해 자동으로 메모리 관리가 가능합니다.

#### ❓ 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?
자바 말고 다른 언어도 JVM에 올릴 수 있습니다. 바이트 코드로 컴파일되는 언어는 모두 JVM 위에서 실행 가능합니다. 대표적으로 코틀린, 스칼라, 그루비, 클로저 등이 있습니다.

#### ❓ 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?
없습니다. 보통 JVM 계열 언어는 JVM 위에서 실행되도록 설계되었기 때문입니다. 하지만 코틀린의 경우 Kotlin/Native를 통해 JVM 없이도 실행 가능한 네이티브 바이너리로 컴파일할 수 있습니다.

#### ❓ VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.
장점은 운영체제 영향을 받지 않는다. spring등과 같은 풍부한 생태계가 있다. 메모리와 스레드를 JVM이 자동으로 처리합니다.
단점은 JVM 자체 메모리 부담이 존재하고, 시작 속도가 느립니다.


#### ❓ JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?
아닙니다. JVM은 독립적인 프로세스이고 내부에서 실행되고 있는 프로그램은 JVM 내부의 스레드로 실행됩니다. 따라서 JVM과 자바 프로그램은 동일 프로세스 내에서 동작하는 관계입니다.

---
### 🔍 2. final 키워드를 사용하면, 어떤 이점이 있나요? 
불변성이 보장되기 때문에 코드 안정성이 증가됩니다. 또한 값이 변경되지 않음을 보장하므로 코드를 예측하기 쉬워집니다. 

#### ❓그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?
final 키워드가 붙은 변수의 경우 변수를 호출하는 대신 실제 값을 호출하기 때문에 성능 향상에 도움이 됩니다.

---

### 🔍 3. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.
추상 클래스는 공통된 상태와 기능을 가진 클래스가 많을 경우 코드 재사용성을 높이기 위해 사용하고, 인터페이스는 클래스들이 동일한 동작을 보장해야 할 때 사용합니다. 또한, 추상 클래스는 단일 상속만 가능하지만 인터페이스는 다중 구현이 가능하기 때문에, 유연한 설계나 확장성을 원할 경우 인터페이스가 적합합니다.

#### ❓ 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?
클래스를 다중 상속할 경우 여러 부모 클래스에 이름이 같은 메서드가 존재할 수 있습니다. 이때 어떤 클래스의 메서드를 호출해야 하는지 판단하기 어렵습니다. 즉, 다이아몬드 문제가 발생합니다. 인터페이스는 매서드에 대한 구현이 없고 선언만 존재하기 대문에 충돌이 일어날 가능성이 없어 2개 이상 구현이 가능합니다.

---

### 🔍 4. 리플렉션에 대해 설명해 주세요.
리플렉션은 클래스로더를 통해 읽어온 클래스 정보를 사용하는 기술입니다. 클래스 이름만 알고 있어도 리플렉션을 사용해 클래스 읽어오거나, 인스턴스를 읽어오거나, 필드의 값을 변경하는 것도 가능합니다.

#### ❓  의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?
setAccessible(true) 접근 제어를 무시할 수도 있고, 코드 인젝션 위험도 있어 보안적인 문제가 존재합니다. 따라서 어떤 클래스가 올지 모르는 동적인 상황을 제외하고서는 사용을 지양하는 것이 좋습니다. 

#### ❓ 리플렉션을 언제 활용할 수 있을까요?
특정 어노테이션이 붙어있는 필드나 메서드를 읽어오거나, 특정 네이밍 패턴에 해당하는 메서드나 필드가 필요한 경우 활용할 수 있습니다.

--- 
### 🔍 5.static class와 static method를 비교해 주세요.
static class는 중첩 클래스에서 사용하는 개념입니다. 외부 클래스 객체 없이 사용 가능하고 내부 클래스지만 독립적으로 동작해야할 때 사용합니다. static method는 클래스 내부의 정적 메서드입니다. 인스턴스 없이 클래스명으로만 호출 가능합니다. 유틸리티 함수와 같이 객체 생성 없이 호출하는 함수를 구현할 때 유용합니다.

#### ❓ static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?
모든 객체가 공유할 수 있다. 객체 생성 없이 접근 가능하기 때문에 빠르게 호출이 가능합니다.
인스턴스 멤버에 접근 할 수 없습니다. static 영역 내에서는 static만 접근 가능하다. this 키워드 사용 불가능하다. 오버라이딩도 불 가능해서 다형성 적용이 어렵습니다.

#### ❓ 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.
인스턴스와 무관하게 JVM이 클래스 로딩 시점에 메모리에 올려 메서드 영역에 저장됩니다. 

--- 
### 🔍 6. Java의 Exception에 대해 설명해 주세요.
Exception은 프로그램 실행 중에 발생할 수 있는 예외 상황을 객체로 표현한 것입니다. 예외 처리를 통해 프로그램이 비정상적으로 종료되지 않도록 제어할 수 있습니다. 최상위 예외 계층인 Throwable 클래스 기준으로 Error와 Exception으로 구분된다. 일반적으로 개발자가 처리하는 예외는 Exception입니다.

#### ❓ 예외처리를 하는 세 방법에 대해 설명해 주세요.
예외 복구는 예외를 try-catch 블록으로 직접 잡아서 처리하는 방법입니다. 예외 발생 시에도 프로그램이 계속 실행될 수 있습니다. 예외 처리 회피는 메서드에 throws를 선언해서 호출한 쪽에서 예외 처리를 하도록 위임하는 방법입니다. 예외 전환은 발생한 예외를 구체적이고 의미있는 예외로 변환해서 던지는 방법입니다.

#### ❓ CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.
CheckedException은 Exception 클래스 중 RuntimeException을 제외한 예외들입니다. 컴파일 시점에 반드시 예외를 처리하도록 강제합니다.  UncheckedException RuntimeException 및 그 하위 클래스입니다. 컴파일 시점에 발견되지 않고 런타임에서 발생합니다.

#### ❓ 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?
예외가 발생하면 JVM은 예외 객체를 생성하면서 stack trace 수집해서 객체에 저장합니다. 이 과정은 단순 메모리 할당보다 무겁기 때문에 성능에 영향을 줄 수 있습니다. stack trace를 제거한 커스텀 예외로 전환해서 부하를 줄이거나 예외 발생 전에 조건을 미리 점검해서 예외 발생 자체를 줄이는 방법이 있습니다. 예외는 꼭 필요한 상황에 사용해야하며 자주 발생하는 상황이라면 예외가 아닌 정상 흐름으로 처리할 수 있도록 설계하는게 좋습니다. 

--- 
### 🔍 7. Synchronized 키워드에 대해 설명해 주세요. 
멀티스레드 환경에서 여러 스레드가 하나의 공유자원에 동시에 접근하지 못하도록 막을 수 있는 키워드입니다. 공유 데이터가 사용되어 동기화가 필요한 부분을 임계영역이라고 부르는데 이 임계영역에 Synchronized 키워드를 사용하여 여러 스레드가 동시에 접근하는 것을 막아 데이터의 일관성을 보장합니다.

#### ❓ Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.
인스턴스 메서드에 설정하면 메서드를 호출한 인스턴스가 임계영역이 됩니다. 정적 메서드에 설정하면 해당 클래스가 임계영역이 됩니다. 코드 블럭에 설정하면 일부 코드만 동기화시킬 수 있어 성능 측면에서 더 유리합니다.

#### ❓ 효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?
간단하고 직관적인 동기화 방법이지만 락을 걸고 풀 때마다 비용이 발생하기 때문에 병렬 처리 효율이 떨어집니다. 효울적인 코드를 작성하기 위해서는 꼭 필요한 부분에만 사용해야하며 락의 범위를 좁히는 게 좋습니다.

#### ❓ Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.
자바는 java.util.concurrent 패키지를 제공합니다. ReentrantLock은 명시적으로 lock을 걸고 해제할 수 있는 클래스입니다. ReadWriteLock은 읽기와 쓰기를 분리하여 락을 관리해 여러 스레드가 동시에 읽기 가능합니다. 

#### ❓ Thread Local에 대해 설명해 주세요.
각 스레드마다 고유한 값을 저장할 수 있는 변수입니다. 스레드마다 고유한 데이터를 유지해야할 때 유용합니다. 메모리 누수 위험이 있으므로 사용 후 반드시 remove() 메서드로 삭제해야합니다.

--- 
### 🔍 8. Java Stream에 대해 설명해 주세요.
Java Stream은 Java 8에서 도입된 기능으로, 컬렉션 데이터를 함수형 방식으로 처리할 수 있도록 지원하는 API입니다.
데이터를 반복적으로 처리할 때 내부 반복(internal iteration)을 통해 선언형 코드로 작성할 수 있어 가독성이 좋고, 병렬 처리도 손쉽게 할 수 있는 장점이 있습니다. Stream은 원본 데이터를 변경하지 않고, 일련의 중간 연산(map, filter 등)과 최종 연산(forEach, collect 등)을 통해 데이터를 처리합니다.

#### ❓ Stream과 for ~ loop의 성능 차이를 비교해 주세요,
간단한 연산을 처리할 때는 stream보다 for loop이 빠릅니다. for loop은 인덱스를 기반으로 동작하지만 Stream은 함수형 인터페이스에 대한 구현체를 만들어야하기 때문입니다. 보통 원시타입의 경우 for loop이 훨씬 빠릅니다. 하지만 연산이 복잡한 경우나 병렬 처리의 경우 스트림의 성능이 더 좋을 수도 있습니다. 

#### ❓ Stream은 병렬처리 할 수 있나요?
Stream은 parallelStream()을 통해 병렬 처리를 지원하고 있습니다. 연산량이 많고 연산이 복잡한 경우, 일반 스트림보다 더 나은 성능을 보일 수 있습니다.

#### ❓ Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.
함수형 인터페이스는 단 하나의 추상 메서드만 가지는 인터페이스입니다. Stream API는 함수형 인터페이스를 통해 람다식을 전달받습니다.

- Runnable: 인자 없이 리턴값도 없는 작업
- Consumer<T>: T 타입 인자를 받고 리턴값 없음 → forEach()
- Supplier<T>: 인자 없이 T 타입 결과 제공 → generate()
- Function<T, R>: T 타입 인자를 받아 R 타입 결과 반환 → map()
- Predicate<T>: T 타입 인자를 받아 boolean 반환 → filter()

#### ❓ 가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?
람다식은 실행 시점에서 다른 스레드에서 실행될 수 있고 지역 변수는 스택에 저장되기 때문에 값을 바로 참조하는 것에 제약이 생깁니다. 따라서 지역 변수의 복사된 값을 이용하게 되는데, 이때 멀티 쓰레드 환경에서 복사 될/복사된 값이 변경 가능 할 경우 이로 인한 동시성 이슈를 대응할 수 없기 때문입니다. final 키워드 뿐만 아니라 변수 선언 이후 값이 변경되지 않은 값인 effectively final 변수도 사용 가능합니다.

