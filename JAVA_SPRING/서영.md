### 🔍 1. JVM이란 무엇인가요?
JVM(Java Virtual Machine)은 바이트 코드를 실행하는 가상 머신입니다. 운영체제와 상관없이 자바 코드를 어디에서나 실행할 수 있게 해주며, 가비지 컬렉터를 사용해 자동으로 메모리 관리가 가능합니다.

#### ❓ 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?
자바 말고 다른 언어도 JVM에 올릴 수 있습니다. 바이트 코드로 컴파일되는 언어는 모두 JVM 위에서 실행 가능합니다. 대표적으로 코틀린, 스칼라, 그루비, 클로저 등이 있습니다.

#### ❓ 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?
없습니다. 보통 JVM 계열 언어는 JVM 위에서 실행되도록 설계되었기 때문입니다. 하지만 코틀린의 경우 Kotlin/Native를 통해 JVM 없이도 실행 가능한 네이티브 바이너리로 컴파일할 수 있습니다.

#### ❓ VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.
장점은 운영체제 영향을 받지 않는다. spring등과 같은 풍부한 생태계가 있다. 메모리와 스레드를 JVM이 자동으로 처리합니다.
단점은 JVM 자체 메모리 부담이 존재하고, 시작 속도가 느립니다.


#### ❓ JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?
아닙니다. JVM은 독립적인 프로세스이고 내부에서 실행되고 있는 프로그램은 JVM 내부의 스레드로 실행됩니다. 따라서 JVM과 자바 프로그램은 동일 프로세스 내에서 동작하는 관계입니다.

---
### 🔍 2. final 키워드를 사용하면, 어떤 이점이 있나요? 
불변성이 보장되기 때문에 코드 안정성이 증가됩니다. 또한 값이 변경되지 않음을 보장하므로 코드를 예측하기 쉬워집니다. 

#### ❓그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?
final 키워드가 붙은 변수의 경우 변수를 호출하는 대신 실제 값을 호출하기 때문에 성능 향상에 도움이 됩니다.

---

### 🔍 3. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.
추상 클래스는 공통된 상태와 기능을 가진 클래스가 많을 경우 코드 재사용성을 높이기 위해 사용하고, 인터페이스는 클래스들이 동일한 동작을 보장해야 할 때 사용합니다. 또한, 추상 클래스는 단일 상속만 가능하지만 인터페이스는 다중 구현이 가능하기 때문에, 유연한 설계나 확장성을 원할 경우 인터페이스가 적합합니다.

#### ❓ 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?
클래스를 다중 상속할 경우 여러 부모 클래스에 이름이 같은 메서드가 존재할 수 있습니다. 이때 어떤 클래스의 메서드를 호출해야 하는지 판단하기 어렵습니다. 즉, 다이아몬드 문제가 발생합니다. 인터페이스는 매서드에 대한 구현이 없고 선언만 존재하기 대문에 충돌이 일어날 가능성이 없어 2개 이상 구현이 가능합니다.

---

### 🔍 4. 리플렉션에 대해 설명해 주세요.
리플렉션은 클래스로더를 통해 읽어온 클래스 정보를 사용하는 기술입니다. 클래스 이름만 알고 있어도 리플렉션을 사용해 클래스 읽어오거나, 인스턴스를 읽어오거나, 필드의 값을 변경하는 것도 가능합니다.

#### ❓  의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?
setAccessible(true) 접근 제어를 무시할 수도 있고, 코드 인젝션 위험도 있어 보안적인 문제가 존재합니다. 따라서 어떤 클래스가 올지 모르는 동적인 상황을 제외하고서는 사용을 지양하는 것이 좋습니다. 

#### ❓ 리플렉션을 언제 활용할 수 있을까요?
특정 어노테이션이 붙어있는 필드나 메서드를 읽어오거나, 특정 네이밍 패턴에 해당하는 메서드나 필드가 필요한 경우 활용할 수 있습니다.

--- 
### 🔍 5.static class와 static method를 비교해 주세요.
static class는 중첩 클래스에서 사용하는 개념입니다. 외부 클래스 객체 없이 사용 가능하고 내부 클래스지만 독립적으로 동작해야할 때 사용합니다. static method는 클래스 내부의 정적 메서드입니다. 인스턴스 없이 클래스명으로만 호출 가능합니다. 유틸리티 함수와 같이 객체 생성 없이 호출하는 함수를 구현할 때 유용합니다.

#### ❓ static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?
모든 객체가 공유할 수 있다. 객체 생성 없이 접근 가능하기 때문에 빠르게 호출이 가능합니다.
인스턴스 멤버에 접근 할 수 없습니다. static 영역 내에서는 static만 접근 가능하다. this 키워드 사용 불가능하다. 오버라이딩도 불 가능해서 다형성 적용이 어렵습니다.

#### ❓ 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.
인스턴스와 무관하게 JVM이 클래스 로딩 시점에 메모리에 올려 메서드 영역에 저장됩니다. 

--- 
### 🔍 6. Java의 Exception에 대해 설명해 주세요.
Exception은 프로그램 실행 중에 발생할 수 있는 예외 상황을 객체로 표현한 것입니다. 예외 처리를 통해 프로그램이 비정상적으로 종료되지 않도록 제어할 수 있습니다. 최상위 예외 계층인 Throwable 클래스 기준으로 Error와 Exception으로 구분된다. 일반적으로 개발자가 처리하는 예외는 Exception입니다.

#### ❓ 예외처리를 하는 세 방법에 대해 설명해 주세요.
예외 복구는 예외를 try-catch 블록으로 직접 잡아서 처리하는 방법입니다. 예외 발생 시에도 프로그램이 계속 실행될 수 있습니다. 예외 처리 회피는 메서드에 throws를 선언해서 호출한 쪽에서 예외 처리를 하도록 위임하는 방법입니다. 예외 전환은 발생한 예외를 구체적이고 의미있는 예외로 변환해서 던지는 방법입니다.

#### ❓ CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.
CheckedException은 Exception 클래스 중 RuntimeException을 제외한 예외들입니다. 컴파일 시점에 반드시 예외를 처리하도록 강제합니다.  UncheckedException RuntimeException 및 그 하위 클래스입니다. 컴파일 시점에 발견되지 않고 런타임에서 발생합니다.

#### ❓ 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?
예외가 발생하면 JVM은 예외 객체를 생성하면서 stack trace 수집해서 객체에 저장합니다. 이 과정은 단순 메모리 할당보다 무겁기 때문에 성능에 영향을 줄 수 있습니다. stack trace를 제거한 커스텀 예외로 전환해서 부하를 줄이거나 예외 발생 전에 조건을 미리 점검해서 예외 발생 자체를 줄이는 방법이 있습니다. 예외는 꼭 필요한 상황에 사용해야하며 자주 발생하는 상황이라면 예외가 아닌 정상 흐름으로 처리할 수 있도록 설계하는게 좋습니다. 

--- 
### 🔍 7. Synchronized 키워드에 대해 설명해 주세요. 
멀티스레드 환경에서 여러 스레드가 하나의 공유자원에 동시에 접근하지 못하도록 막을 수 있는 키워드입니다. 공유 데이터가 사용되어 동기화가 필요한 부분을 임계영역이라고 부르는데 이 임계영역에 Synchronized 키워드를 사용하여 여러 스레드가 동시에 접근하는 것을 막아 데이터의 일관성을 보장합니다.

#### ❓ Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.
인스턴스 메서드에 설정하면 메서드를 호출한 인스턴스가 임계영역이 됩니다. 정적 메서드에 설정하면 해당 클래스가 임계영역이 됩니다. 코드 블럭에 설정하면 일부 코드만 동기화시킬 수 있어 성능 측면에서 더 유리합니다.

#### ❓ 효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?
간단하고 직관적인 동기화 방법이지만 락을 걸고 풀 때마다 비용이 발생하기 때문에 병렬 처리 효율이 떨어집니다. 효울적인 코드를 작성하기 위해서는 꼭 필요한 부분에만 사용해야하며 락의 범위를 좁히는 게 좋습니다.

#### ❓ Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.
자바는 java.util.concurrent 패키지를 제공합니다. ReentrantLock은 명시적으로 lock을 걸고 해제할 수 있는 클래스입니다. ReadWriteLock은 읽기와 쓰기를 분리하여 락을 관리해 여러 스레드가 동시에 읽기 가능합니다. 

#### ❓ Thread Local에 대해 설명해 주세요.
각 스레드마다 고유한 값을 저장할 수 있는 변수입니다. 스레드마다 고유한 데이터를 유지해야할 때 유용합니다. 메모리 누수 위험이 있으므로 사용 후 반드시 remove() 메서드로 삭제해야합니다.

--- 
### 🔍 8. Java Stream에 대해 설명해 주세요.
Java Stream은 Java 8에서 도입된 기능으로, 컬렉션 데이터를 함수형 방식으로 처리할 수 있도록 지원하는 API입니다.
데이터를 반복적으로 처리할 때 내부 반복(internal iteration)을 통해 선언형 코드로 작성할 수 있어 가독성이 좋고, 병렬 처리도 손쉽게 할 수 있는 장점이 있습니다. Stream은 원본 데이터를 변경하지 않고, 일련의 중간 연산(map, filter 등)과 최종 연산(forEach, collect 등)을 통해 데이터를 처리합니다.

#### ❓ Stream과 for ~ loop의 성능 차이를 비교해 주세요,
간단한 연산을 처리할 때는 stream보다 for loop이 빠릅니다. for loop은 인덱스를 기반으로 동작하지만 Stream은 함수형 인터페이스에 대한 구현체를 만들어야하기 때문입니다. 보통 원시타입의 경우 for loop이 훨씬 빠릅니다. 하지만 연산이 복잡한 경우나 병렬 처리의 경우 스트림의 성능이 더 좋을 수도 있습니다. 

#### ❓ Stream은 병렬처리 할 수 있나요?
Stream은 parallelStream()을 통해 병렬 처리를 지원하고 있습니다. 연산량이 많고 연산이 복잡한 경우, 일반 스트림보다 더 나은 성능을 보일 수 있습니다.

#### ❓ Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.
함수형 인터페이스는 단 하나의 추상 메서드만 가지는 인터페이스입니다. Stream API는 함수형 인터페이스를 통해 람다식을 전달받습니다.

- Runnable: 인자 없이 리턴값도 없는 작업
- Consumer<T>: T 타입 인자를 받고 리턴값 없음 → forEach()
- Supplier<T>: 인자 없이 T 타입 결과 제공 → generate()
- Function<T, R>: T 타입 인자를 받아 R 타입 결과 반환 → map()
- Predicate<T>: T 타입 인자를 받아 boolean 반환 → filter()

#### ❓ 가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?
람다식은 실행 시점에서 다른 스레드에서 실행될 수 있고 지역 변수는 스택에 저장되기 때문에 값을 바로 참조하는 것에 제약이 생깁니다. 따라서 지역 변수의 복사된 값을 이용하게 되는데, 이때 멀티 쓰레드 환경에서 복사 될/복사된 값이 변경 가능 할 경우 이로 인한 동시성 이슈를 대응할 수 없기 때문입니다. final 키워드 뿐만 아니라 변수 선언 이후 값이 변경되지 않은 값인 effectively final 변수도 사용 가능합니다.

--- 
### 🔍 9. Java의 GC에 대해 설명해 주세요.
가비지 컬렉션은 더 이상 사용하지 않는 객체를 자동으로 메모리에서 해제하는 기능입니다. 개발자가 직접 메모리를 할당하고 해제할 필요가 없습니다. GC는 주기적으로 실행되며 어떤 곳에서도 참조되지 않는 객체를 찾아 메모리에서 제거합니다. 따라서 메모리 누수 방지 및 안정적인 메모리 관리가 가능합니다.

#### ❓ finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?
아직 참조되고 있는데 해제하면 예상하지 못한 문제가 생길 수 있습니다. 이미 해제되어 있는데 또 해제를 하면 이중 해제 문제가 발생합니다.
실행 순서가 보장되지 않아 안정성이 떨어지며 객체 생명 주기를 혼란스럽게 만들기 때문에 수동으로 호출하는 것이 권장되지 않습니다.

#### ❓ 어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?
어떤 변수의 값이 null이 되었다고 해서 무조건 GC가 되는 것은 아닙니다. 다른 변수 또한 null이 된 객체를 참조하고 있지 않아야 GC대상이 됩니다. 즉,  다른 어떤 곳에서도 해당 객체를 참조하고 있지 않아야 GC 대상이 됩니다. 

--- 
### 🔍 10. equals()와 hashcode()에 대해 설명해 주세요.
equals()는 두 객체가 논리적으로 동일한지를 비교합니다. 기본적으로 객체의 참조값이 같은지 판단하는데 객체의 특정 필드로 비교하고 싶다면 equals()를 오버라이딩해야 합니다. hashcode()는 해시 기반 컬렉션에서 객체를 저장하고 검색하는데 사용됩니다. equals() 실행 결과와 hashcode() 실행 결과가 일치해야하기 때문에 equalsl()를 오버라이딩했다면 hashcode()도 함께 오버라이딩 해줘야합니다.

#### ❓ 본인이 hashcode() 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?
equals()로 동일하다고 판단된 두 객체는 반드시 같은 해시코드를 가져야합니다. equals()에서 사용되는 값을 기반으로 정의해야합니다.

#### ❓ 그렇다면 equals() 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.
- 반사성: 객체는 자기 자신과 동등해야합니다.
- 대칭성: 두 객체의 동등성 비교는 일관되어야 합니다.
- 추이성: 연속적인 동등성 비교가 일관되어야 합니다.
- 일관성: 객체가 상태가 변경되지 않은 한 eqauls() 결과는 동일해야합니다.
- null 처리: null과의 비교는 항상 fasle를 반환해야한다.


---
### 🔍 11. IoC와 DI에 대해 설명해 주세요.
IoC(제어의 역전)은 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 프레임워크와 같은 외부에서 관리하는 것입니다. 
DI(의존성 주입)는 제어의 역전을 구현하는 방법 중 하나입니다. 애플리케이션 실행 시점에 필요한 객체를 외부에서 만들어서 주입해주는 방식입니다. 이렇게 하면 클라이언트 객체는 자신이 의존하는 구현체를 직접 만들지 않고, 외부에서 주입받기 때문에 실제 의존 관계가 외부에서 연결되게 됩니다.

#### ❓ 후보 없이 특정 기능을 하는 클래스가 딱 한 개라면, 구체 클래스를 그냥 사용해도 되지 않나요? 그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?
스프링 컨테이너는 빈을 생성하고 의존성 주입을 담당합니다. 현재 클래스가 딱 한 개라도 추후 기능이 확장될 때 구현체만 교체하면 되기 때문에 유연하게 대체할 수 있습니다. 또한 스프링 컨테이너는 싱글톤 스코프로 빈을 관리하기 때문에 요청이 많이 들어와도 하나의 인스턴스로 재사용하기 때문에 메모리 효율성도 좋습니다.

#### ❓ Spring의 Bean 생성 주기에 대해 설명해 주세요.
Spring의 Bean은 먼저 스프링 컨테이너에 의해 객체가 생성되고, 필요한 의존성들이 주입됩니다. 이후에는 초기화 콜백 메서드가 실행되어 초기화 작업이 이루어집니다. 이렇게 준비된 빈은 애플리케이션 전반에서 사용되며, 스프링 컨테이너가 종료되기 직전에는 소멸 콜백이 호출되어 리소스를 정리하고 안전하게 종료됩니다.

#### ❓ 프로토타입 빈은 무엇인가요?
스프링 컨테이너에 요청이 들어올 때마다 새로운 빈을 생성하는 빈 스코프입니다. 스프링 컨테이너는 빈 생성 후 의존관계 주입, 초기화까지만 담당하며 그 이후는 책임지지 않습니다. 따라서 자동으로 종료 메서드가 호출되지 않아 빈을 조회한 클라이언트가 직접 종료 메서드를 호출해야합니다.
