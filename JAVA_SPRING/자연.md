
### 1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.
  - 자바는 특정 운영체제(OS)에 종속되지 않고 쓸 수 있다는 장점이 있다. 이 장점을 수행하는 것이 자바가상머신(Java Virtual Machine)이다. JVM은 JavaC를 통해 컴파일된 바이트 코드를 기계가 이해할 수 있는 바이너리코드(기계어)로 변환하며, 메모리 관리와 가비지 컬렉터를 수행한다.

  #### 1-2. 그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?
  - 다른 언어의 바이트코드도 인식하기 때문에 가능하다. ex) 코틀린, 스칼라, 그루비

  #### 1-3. 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?
  - JVM 계열 언어란 JVM 위에서 실행되는 프로그래밍 언어를 말한다(코틀린, 스칼라, 그루비 등)
  - 바이트 코드 : 가상머신이 이해할 수 있는 코드
  - 바이너리 코드 : 컴퓨터가 인식 가능한 이진코드
  - 네이티브 코드 : 특정 프로세서에서 실행하기 위해 컴파일된 언어 ex) c, c++ 컴파일 -> 네이티브 코드 생성됨(JVM 필요x)
  - JVM계열 언어는 기본적으로 JVM에서 실행되는 바이트코드로 컴파일되서 일반적으로 컴파일해서 사용할 수 없지만 GraalVM 같은 컴파일러를 통하여 가능하다. 
  #### 1-4. VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.
  - 장점 : VM을 통해 한 컴퓨터로 여러 대의 컴퓨터를 사용하는 효과를 낼 수 있다. 격리된 환경을 제공하여 서로 영향을 받지 않는다.
  - 단점 : Host 컴퓨터 성능에 영향을 받음, 가상 장치라 실제 컴퓨터보다 느림, VM이 많아질 수록 안정성 하락, VM마다 각각 OS를 가져 용량의 부담이 됨

  #### 1-5.  JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?
  - JVM은 운영체제 내에서 실행되는 프로그램이며 프로세스 단위로 진행되고, 프로세스 내의 스레드로 동시에 여러 작업을 처리한다. 부모 프로세스 - 자식 프로세스 관계와 다르다. 스레드는 자원 공유를 통해 프로세스 내부의 다른 스레드와 통신하며, 효율적으로 움직인다. 결론은 단일 프로세스 - 스레드 관계이다.

--- 

### 2. final 키워드를 사용하면, 어떤 이점이 있나요?
  - final 키워드는 클래스, 메서드, 변수에서 사용되는데 클래스는 상속이 불가능하도록, 메서드는 오버라이딩가 불가능하고, 변수는 상수화를 시킨다. 즉 중요한 값이나 메서드 등을 변경하지 않고 사용할 수 있다.

  #### 2-2. 그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?
  - 상속, 오버라이딩, 변수 값 재할당 등이 불가능하기 때문에, JVM이 컴파일 시 최적화 할 수 있다. (무조건 속도가 빨라지는 것은 아니다.)

---

### 3. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.
  - 인터페이스는 구현 객체의 '동일한 실행'을 보장하기 위한 목적, 하위클래스 메소드(구현부) 구현 강제 / implements / 다중상속 가능
  - 추상클래스는 상속 받아서 기능을 '확장' 시키는 목적 / extends / 단일상속만 가능
    
#### 3-2. 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?
  - 상속의 모호성 문제, 상속 구조 복잡성이 증가 하기 때문에 클래스는 단일 상속을 원칙으로 하며, 인터페이스는 구현체를 제공하지 않기 때문에 다종 상속이 가능하다. 충돌 시 메서드 오버라이딩을 통해 충돌을 해결할 수 있다.

---

### 4. 리플렉션에 대해 설명해 주세요.
- 실행 중에(런타임 중) 동적으로 특정 클래스의 정보를 추출, 조작할 수 있는 Java API이다. 객체 생성, 메서드 호출 등이 가능하기 때문에 -> 코드의 유연성, 확장성이 높아진다.
- Class, Constructor, Method, Field의 정보를 알 수 있다.
- (단점) 컴파일러의 최적화가 어려우며, 일반적 메서드보다 성능이 느리다.

  #### 4.2. 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?
  - 실제로 private 메서드, 필드에 접근할 수 있기 때문에, 보안 면에서 큰 취약점이 될 수 있다.
  - 보안매니저(SecurityManager)를 사용하여 보안정책 제어, 코드 컴사와 테스트, 최소한의 권한 부여 등의 조치를 취할 수 있다.
 
  #### 4.3. 리플렉션을 언제 활용할 수 있을까요?
  - 스프링 프레임워크 : 리플렉션으로 의존성 주입 / 하이버네이트 : 리플렉션을 통해 객체-DB 매핑 / JUnit : 리플렉션을 통해 테스트 케이스 동적 로딩 & 실행
 
---
### 5. static class와 static method를 비교해 주세요.
  - static class : Outer 클래스 + Inner 클래스 사용시 외부 참조, 메모리 누수 현상의 단점 때문이 발생한다. static class를 통해 이러한 단점을 해결할 수 있다. 외부 인스턴스 x -> 외부참조x 
  - static method : 객체 생성 없이 호출이 가능한 메소드 / 메소드 내에서 인스턴스 변수를 사용할 수 없다. 

  #### 5.2. static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?
  - static을 사용하면 인스턴스 생성 없이 바로 사용이 가능하며, 메모리 여역에서 고정된 영역만을 사용하기 때문에 매번 인스턴스 생성, 낭비되는 메모리를 줄일 수 있다.
  - 프로그램 종료 시 까지 메모리에 할당된 채로 존재하여 남발 시 메모리, 프로그램 자체가 느려질 수 있다. 객체를 생성하지 않고 사용하기 때문에 객체지향적이지 못하다. (OP 원칙 위반)

  #### 5.3. 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.
  - javaC에 의해 class 파일로 로드될 시 우선적으로 method 영역 메모리에 할당된다. 그러므로 객체가 heap 영역 메모리에 올라가기 전에 호출해서 사용할 수 있다. 


---
### 6. Java의 Exception에 대해 설명해 주세요.
  - Java의 예외(exception)이란 사용자의 조작이나, 개발자의 코딩 실수 등으로 발생하는 오류를 말한다.

  #### 6.2. 예외처리를 하는 세 방법에 대해 설명해 주세요.
  - try ~  catch ~ finally : 예외발생은 try 다음 / 예외처리는 catch 다음 / 무조건 실행되야하는 문법은 finally 다음
  - throws : 메소드를 호출한 곳으로 예외 처리를 떠넘긴다 ex) method2() throws ....Exception {}
  - throw new ~exception : 사용자 정의 예외 클래스이며 예외 테스트를 하기 위해 강제로 발생시키는 예외를 말한다.

  #### 6.3. CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.
  - CheckedException : 개발자가 반드시 예외처리해야하는 오류이며, 미 처리시 런타임이 불가능하다.
    ex) 잘못된 클래스명, 데이터 형식 오류 등
  - UnChckedException : 예외처리를 하지 않아도 런타임에 문제가 없는 오류이다. 
    ex) NullPointerException / ArrayIndexOutOfBoundsException 등

  #### 6.4. 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?
  - 예외 발생 시 JVM은 exception handler가 포함된 메서드를 찾기 위해 call stack(호출 스택)을 검색한다. 찾을 때까지 탐색하고 없는 경우 예외 객체를 전달하여 오류를 발생한다. -> call stack을 탐색하며 비용이 발생한다. 예외 발생 환경 등에 따라 비용 시간은 다르다. 
  - Return object : 예외 발생대신 empty 객체 리턴 / 다른 응답 처리
  - Overriding fillInStackTrace Method : 자바 기존 제공 예외가 아닌 커스텀 exception은 유효하지 않는 값일 때 비지니스 로직을 수행하기 못한 용도로 사용된다. 오버라이드로 stackTrace 생성 비용을 줄인다.
  - Caching an exception : static final로 선언하여 상수값 형태로 예외를 캐싱하고 사용한다.
--- 

### 7. Synchronized 키워드에 대해 설명해 주세요.
  - 자바 멀티스레드 환경에서 여러 스레드가 하나의 공유자원에 동시에 접근하지 못하도록 막는 것이다. 공유데이터가 사용되는 부분을 임계 영역(critical section)이라고 부르며, 자바에서는 임계영역에 synchronized 키워드를 사용한다.
  #### 7.2. Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.
  - sychronized method : 클래스의 인스턴스 lock
  - static synchronized method : 인스턴스가 아닌 클래스 단위
  - synchronized block : 인스턴스 block 단위로 lock (객체 지정 필수) ex synchronized (this) {...}
  - static synchronized block : static method + block 클래스 단위로 lock

  #### 7.3. 효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?
  - 과도한 동기화는 스레드 경쟁으로 인한 성능 저하를 일으킬 수 있다.
  - 스레드가 락을 반납하지 않으면, 다른 스레드가 무한정 대기하는 상황이 발생할 수 있다.
  - 대다수의 서버가 스케일아웃으로 여러대의 서버를 실행하고, 로드밸런스로 부하 분산하여 서비스를 제공하는데,synchronized는 하나의 프로세스 내에서만 동시성 보장 -> 다중서버 x

  #### 7.4. Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.
  - synchronized :CPU메모리 영역에 데이터 캐싱 
  - volatile : 메인 메모리 영역에서 값을 참조 -> 최신의 값 유지 (단, 원자적 연산일 때만)
  - concurrent 패키지의 atomic 클래스 이용

  #### 7.5. Thread Local에 대해 설명해 주세요.
  - Java의 Thread safe기술로, 멀티 스레드 환경에서 각각의 스레드가 별도의 저장공간을 할당받아 각 상태를 갖을 수 있는 것
  - 주의점 : ThreadLocal 사용 후 비워주지 않으면 다른 사용자가 데이터를 공유하게 될 수도 있음
  - 사용처 : Spring Security내 context보관 등

---
### 8. Java Stream에 대해 설명해 주세요.
  - 일련의 데이터 흐름을 표준화된 방법으로 쉽게 처리할 수 있도록 지원하는 '클래스의 집합(패키지)' 이다.
  - 생성 -> 가공(filter, map..) -> 소비의 구조로 구성됨
  - 재사용이 불가능하며, 원본 데이터를 변경하지 않는다.
  - 
#### 8.2. Stream과 for ~ loop의 성능 차이를 비교해 주세요.
  - Stream : 가독성이 좋다, 코드가 짧다. 단, 함수형 프로그래밍 특징인 불변성을 위해 복사를 해 메모리 증가, 오버헤드 등으로 속도가 느리다.
  - For ~ loop : 처리속도와 메모리 효율성이 Stream보다 좋다. 

#### 8.3. Stream은 병렬처리 할 수 있나요?
  - 병렬처리 : 멀티스테르도 병렬 처리 후 합치는 과정 -> 대량 데이터 쉽게 처리
  - parallel() / parallelStream() 추가
    
#### 8.4. Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.
  - 함수형 인터페이스 : 추상메소드가 단 하나 뿐인 인터페이스
  - Function<T, R> : T 인자 받고, R 리턴
  - Predicate<T> : T받고 boolean 리턴
  - Consumer<T> : T받고 리턴값 없음..
    
#### 8.5. 가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?
  - 가변 변수 사용 시 : 동시성 문제(내부 병렬처리로 인해 데이터 무결성x), 예측 불가능한 동장(스트림의 연산은 지연실행되거나 최적화 될 수 있음), 가독성 및 유지보수성 저하(가변상태라 코드 추적 어려움)
  - 위의 이유 때문에 final 키워드를 붙여 사용한다. 

---
### 9. Java의 GC에 대해 설명해 주세요.
  - Garbage Collection : JVM이 Heap 영역에서 필요없게 된 메모리 객체(garbage)를 모아 주기적으로 제거하는 프로세스를 말한다. c/c++ 에서는 프로그래머가 수동으로 메모리 할당과 해제를 하지만, 가비지 컬렉터가 메모리 관리를 대행 -> 개발자 입장 메모리관리, 메모리 누수 문제보다 개발에 집중할 수 있음.
  - GC는 객체가 참조되고 있는 상태 여부로 제거 객체를 결정한다.
    여러가지 GC 알고리즘이 있어 설정을 통해 Java에 적용할 수 있다.
  - 파이썬, JS, GO언어 등에도 내장되어 있다.
  - 단점 : 자동처리지만 메모리가 정확히 언제 해제되는지 알 수 없어 제어하기 힘들며, GC 동작 중에는 다른 동작이 멈추기 때문에 오버헤드가 발생되는 문제점이 있다. (= STW Stop The World)
  - STW : GC 작동 스레드 제외 모든 스레드는 멈추게 됨
  - 오버헤드 : 어떤 처리를 하기 위해 "추가로" 들어가는 처리 시간, 메모리

#### 9.2. finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?
  - finalize() : GC에 의해 객체가 제거될 때 실행되는 메소드. 객체가 사용하던 자원을 해제하거나, 정리 등의 작업을 수행
  - 어떤 스레드가 실행하는지 예측이 불가능 -> 불확실한 실행, GC는 단순히 메모리에서 회수하는 것 이상의 작업을 실행, 동시성 문제 야기 가능, 보안 취약점, finalize() 내의 예외는 JVM에 의해 잡히지 않음
  - 대안 : 자바9 Cleaner / AutoCloseable 인터페이스 / try-with-resources
    
#### 9.3. 어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?
  - GC의 대상은 객체가 Null인 경우, 블럭 실행 종료 후 블럭 내에서 실행된 객체, 부모 객체가 null 인 경우 포함되는 자식 객체이므로 가능성이 있다.
    
---
### 10. equals()와 hashcode()에 대해 설명해 주세요.
  - eqausl()는 두 객체의 동등성 비교 시 사용된다. 참조 주소를 통해 동일 객체인지 확인한다. -> 동일값 이지만 서로 다른 객체인 경우에 같은 객체로 인식 되어야 하기 때문에 equal() 메서드를 오버라이딩해 재정의한다. 
  - hashcode()는 객체의 해시 코드 값을 반환하는데 사용된다.
  - equals()메서드를 재정의 할 때 hashcode() 메서드도 함께 재정의 해야한다. 1차적으로 동등하다고 판단된 객체의 해시 코드 값을 확인해서 확정 짓기 때문이다.
  - 결론 : equal가 동등하면 hashcode도 동등 / BUT / hascode 동등 -> 무조건 equals 동등은 아니다.
  - 예시 : String.class에서도 equals()를 재정의해 같은 객체거나 문자열 비교 같은 값일 시 true로 리턴한다.

#### 10.1. 본인이 hashcode() 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?
  - 재정의를 하지 않으면 같은 값을 가진 객체가 다른 해시값을 가질 수 있다.
  - equals 정보가 변경되지 않으면, hashcode()는 항상 같은 값을 반환해야한다.
  - 두 객체가 equals()로 동일하면, hashcode() 값도 일치해야하는 점
  - 해시 충돌 : equals()가 달라도, hashcode() 값은 같을 수 있음 -> LinkedList 형태로 객체를 추가한다.

#### 10.2. 그렇다면 equals() 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.
  - instanceof 연산자로 올바른 타입인지 확인할 것
  - 5가지의 일반 규약을 따를 것 : 반사성, 대칭성, 추이성, 일관성, null아님
  - 반드시 hashcode()도 재정의해야함

---
### 11. IoC와 DI에 대해 설명해 주세요.
  - IOC (Inversion of Control, 제어의 역전)
    - 객체(빈)의 생명주기를 개발자 대신 프레임워크가 관리하는것 / IOC 컨테이너(스프링 컨테이너)에 의해 관리됨
  - DI (Dependency Injection, 의존성 주입)
    - 빈 설정 정보를 바탕으로 컨테이너가 외부에서 객체를 생성해 필요한 클래스에 주입하는 패턴.
    - 생성자 주입(@Contoller), 수정자 주입, 필드주입(@Autowired)
    - 모듈 간 결합도를 낮출 수 있고(의존성x이므로), 코드의 재사용성을 높임
    
  #### 11.2. 후보 없이 특정 기능을 하는 클래스가 딱 한 개하면, 구체 클래스를 그냥 사용해도 되지 않나요? 그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?
  - Bean : 스프링 프레임워크에서 관리되는 객체이며, 빈 컨테이너에 의해 관리됨
  - 구체 클래스(=구상 클래스, 구현 클래스, Concrete Class)
  - new 키워드로 인스턴스 생성가능한 클래스
  - new로 생성시 강한 결합도-> 변경어려움 
  - Spring Bean 사용 시
    - DI으로 결합도를 낮출 수 있음(타클래스 의존성 down)
    - 객체 생명 주기를 관리해줌
    - 싱글톤 관리로 메모리 효율성 up
    - 테스트 용이성

  #### 11.3. Spring의 Bean 생성 주기에 대해 설명해 주세요.
  - 스프링 컨테이너 생성 -> Bean 생성 -> 의존성 주입 -> 초기화 콜백 -> Bean사용 -> 소멸전 콜백 -> 스프링 종료
  - 초기화콜백(init) : Bean 생성 + 의존성 주입 -> 초기화콜백
  - 소멸 전 콜백(destroy) : 스프링 종료 전, Bean 소멸 직전 호출

  #### 11.4. 프로토타입 빈은 무엇인가요?
  - 스프링에서 빈을 등록하면 싱글톤으로 만들어 지므로 매번 같은 객체를 반환한다. (생명주기 싱글톤 = 스프링 컨테이너)
  - 싱글톤이 아닌 하나의 빈으로 여러개의 객체를 만들고 싶을 때 사용하는 것이 프로토타입 빈이다.
  - @Resource나, @Autowired 등을 이용해 의존관계 주입을 한 후 프로토타입 빈을 가져오려면 싱글톤 빈처럼 작동하기 때문에 ApplicationContext.getBean을 사용해서 다른 객체를 가져와야한다.
  - 생명주기가 관리되는 스프링 빈과 달리, 프로토타입 빈은 개발자가 직접 관리해야한다.

---
### 12. AOP에 대해 설명해 주세요.
  - AOP (Asepect Oriented Programming, AOP / 관점지향 프로그래밍)
  - 어떤 로직을 핵심 관점(비지니스 로직) + 부가 관점(인프라 로직)으로 나누어 모듈화 하겠다는 프로그래밍 방식
  - 횡단 관심사
    - 비지니스 로직 수행 시 인프라 로직(부가기능)의 중복이 횡단으로 나타나는 것을 횡단 관심사라고 부른다.
  - 횡단 관심사를 모듈화하고 핵심적인 비지니스 로직에서 분리하여 재사용하겠다는 것이 AOP이다.
  - OOP : 핵심 비지니스 로직 클래스 모듈화 -> AOP : OOP + 부가기능(Aspect) 모듈화

  #### 12.2. @Aspect는 어떻게 동작하나요?
  - @Aspect 주요 개념
      1. Advice : 실행될 부가 기능 정의 부분
      2. JoinPoint : Advice가 적용될 수 있는 지점 (메서드 실행 지점)
      3. Pointcut : Advice가 적용될 메서드를 지정하는 표현식
      4. Weaving : 실제 코드 + advice 적용 과정
  - 클래스에 @Aspect + @Component / @Bean 스프링 빈으로 등록
  - PointCut에 해당하는 메서드 찾아 Advice 적용
  - 메서드 실행 시 Advice가 Pointcut에 맞는 메서드 앞/뒤/주변 실행
  - 런타임 시 동적으로 적용

---
### 13. Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.
  - 인터셉터
    - 특정 URI의 요청, 응답을 가로채서 원하는 동작을 추가하는 역할 (컨트롤러 밀접 로직)
    - 스프링에서 관리되어 스프링 내 모든 객체(빈)에 접근 가능
    - Dispatcher Servlet 실행 후 호출 / D.S ---(인터셉터) -----Contoller
    - spring-servlet.xml
    - ex) 관리자 페이지에 관리자 인증 같은 세부 보안 인증, 인가 공통 작업, API호출 로깅 검사, 컨트롤러로 넘기는 정보(데이터) 가공
  - 서블릿 필터
    - Dispatcher Servlet 전, 후에 동작하여 사용자의 요청, 응답 최전방에 존재 (모든 요청 전처리/후처리 데이터변형)
    - 동일 웹 어플리케이션 내에서 동작, 자원 활용 -> 스프링 Context 접근이 어려움
    - Request, Response를 조작할 수 있다. -> body 수정 가능
    - web.xml 설정
    - ex ) 보안, 인증, 인가, 로깅, 이미지, 데이터 인코딩 등 Spring과 무관하게 전역처리해야하는 작업

  #### 13.2 설명만 들어보면 인터셉터만 쓰는게 나아보이는데, 아닌가요? 필터는 어떤 상황에 사용 해야 하나요?
  - 필터는 인터셉터는 불가능한 request, response를 조작할 수 있습니다. 또한 dispatch Servlet 전에도 호출할 수 있기 때문에 dispatch servlet 호출 후에만 작동하는 인터셉터와는 차이를 가집니다. 필터는 보안, 인증, 인가, 이미지 인코딩 등 Spring과 무관하게 전역처리해야하는 작업에 사용됩니다. 

---
### 14. Dispatcher-Servlet 의 역할에 대해 설명해 주세요.
  - HTTP 프로토콜로 들어오는 모든 요청을 먼저 받아 적합한 컨트롤러에 위임해주는 프론트 컨트롤러
  - 기존에 web.xml에 url 매핑을 모두 등록해야했으나 그 역할을 대체하여 효율성을 높여줌
  - 열심히 요청을 받다보니 HTML 같은 정적 파일 요청마저 가로채어 문제 발생 -> 애플리케이션 요청 탐색 후 없으면 정적 자원 요청으로 처리
  - 처리 방식
    1. 클라이언트 요청을 Dispatcher Servlet이 받음
    2. 요청 정보를 통해 위임할 컨트롤러를 찾음
    3. 컨트롤러로 위임할 핸들러 어댑터를 찾아서 전달함
    4. 핸들러 어댑터 -> 컨트롤러로 요청 위임
    5. 비지니스 로직 처리
    6. 컨트롤러가 반환값 반환
    7. 핸들러 어댑터가 반환값 처리
    8. 서버의 응답을 클라이언트로 반환

  #### 14.2 여러 요청이 들어온다고 가정할 때, Dispatcher-Servlet은 한번에 여러 요청을 모두 받을 수 있나요?
  - 서블릿 컨테이너가 멀티 스레드 환경에서 동작하기 때문에 가능하다.
  - 서블릿 컨테이너는 스레드 풀을 생성하여 사용하고, 클라이언트의 요청을 각 스레드에 할당하기 때문에 각 요청은 독립적인 스레드에서 처리된다.
  - 또한 HttpServletRequest와 HttpServletResponse 객체를 사용하여 데이터의 충돌이 발생하지 않고 동시성을 보장한다.

  #### 14.3 수많은 @Controller 를 DispatcherServlet은 어떻게 구분 할까요? 
  - HandlerMapping 를 통한 매핑 또는 @Contoller, @RequestMapping 과 같은 어노테이션으로 식별하여 찾는다. 


  ---
  ### 15. JPA와 같은 ORM을 사용하는 이유가 무엇인가요?
  - 애플리케이션에서 SQL Mapper(Mybatis등) 를 통해 개발자가 SQL을 직접 다룰 때 발생하는 문제점에는 객체지향적이지 않고 SQL에 의존적이라는 것이다. 엔티티를 신뢰할 수 없고, SQL 실행문이나 DAO 내용을 확인해야한다. 또한 강한 의존관계 때문에 필드 추가 시 CRUD와 SQL을 항상 변경해야한다는 단점이 있었다.
  - ORM을 사용하는 이유는 객체지향적이며 패러다임 불일치 문제를 해결할 수 있다는 장점 때문이다.
  - 패러다임 불일치 : 객체 / RDB가 지향하는 목적이 달라 기능, 표현 방법의 차이에서 발생해서 생기는 문제
  - JPA(Java Persistence API) : 자바의 ORM(Object-Relational Mapping) : 객체와 엔티티를 직접 매핑하여 위 문제를 해결한다.
    - 객체지향적 프로그래밍
    - 생산성 증가 : CRUD용 SQL을 직접 작성할 필요 없이 객체로 다룰 수 있음
    - 편리한 유지보수 : 엔티티에 필드 추가시 수동으로 전부 바꾸었던 업무를 JPA가 대신 처리해줌
    - 성능 최적화
    - 데이터 접근 추상화 + 벤더 독립성 : JPA 애플리케이션이 특정 DB에 종속되지 않는다.
    - (단점) DB 관계 복잡하면 쿼리 작성에 어려움 / 데이터 관계 복잡하면 구현이 어려움
    
  #### 15.2 영속성은 어떤 기능을 하나요? 이게 진짜 성능 향상에 큰 도움이 되나요?
  - 영속성(Persistence) : 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성이며 영속성이 없으면 데이터는 메모리에서만 존재하다가 사라진다. 
  - 영속상태 : EntityManager의 persist()를 통해 객체를 저장한 상태. (1차캐시)
  - 영속성 컨테스트의 역할
    - 엔티티 저장 및 관리, 변경감지(Dirty Checking), 1차 캐시, 쓰기 지연(Batching)   
  - 영속성의 성능향상
    - DB접근 최소화(1차캐시), 자동변경 감지(엔티티 변경 시 update쿼리 자동생성), 쓰기 지연 및 배치 처리(1건씩 날리는게 아니라 모아서 날리기 때문에 DB와의 통신 횟수 줄임), 캐싱 효과(영속성 컨테스트 + 2차캐시 설정 -> 접근 속도 향상)

  #### 15.3 N + 1 문제에 대해 설명해 주세요.
  - N+1문제 : 하나의 쿼리로 N개의 데이터를 가져온 후, 각 데이터의 연관된 엔티티를 조회하기 위해 추가로 N개의 쿼리를 실행-> 성능저하(N+1번의 쿼리 실행)
  - Fetch 즉시 로딩 : User내의 Team 엔티티도 바로 생성해야하므로 영속성 컨테스트 확인 후 Team 갯수에 맞춰 N+1 생성
  - Fetch 지연 로딩 : User내의 Team을 사용하는 시점에 위와 같은 과정
  - 해결방법 : Fetch Join, EntityGraph 어노테이션, Batch Size
    - Fetch Join : JPQL을 사용하여 DB에서 데이터를 가져올 때 연관된 데이터까지 통째로 가져오게 하는 방법이다.
    - @EntityGraph 어노테이션
    - Batch Size : N+1문제가 발생하더라도 in (?, ?) 방식으로 1번만 더 조회해서 해결하는 방법
    - 연관관계는 언제나 지연로딩을 사용 + 최적화가 필요하면 Fetch 조인을 사용 + 기본 Batch Size값 1000이하 설정

  ---
  ### 16. @Transactional 은 어떤 기능을 하나요?
  - 특정 메서드, 클래스에서 수행되는 '트랜잭션'의 관리를 위해 사용하는 어노테이션 (선언적 트랜잭션)
  - 트랜잭션을 시작하고 커밋, 롤백할 수 있으며, 예외 발생 시 롤백이 처리된다. 
  - 속성
    - propagation : 전파 동작 지정 (새 트랜잭션..기존 트랜잭션..일시정지 등의 상태관리)
    - isolation : 격리 수준 지정
    - timeout : 트랜잭션 제한 시간
    - readOnly : 읽기 전용 여부
    - rollbackFor : 롤백 예외 지정
    - noRollbackFor : 롤백 일으키지 않는 예외 지정
  - 활용예시
    - 비지니스 로직을 담는 서비스 계층의 메소드와 결합
    - 읽기 전용 트랜잭션 공통화 -> DB 성능 최적화
    - 트랜잭셔널 클래스 내 @Test 어노테이션 사용 시 테스트의 DB커밋을 롤백해줌

  #### 16.2 @Transactional(readonly=true) 는 어떤 기능인가요? 이게 도움이 되나요? 그런데, 읽기에 트랜잭션을 걸 필요가 있나요? @Transactional을 안 붙이면 되는거 아닐까요?
  - @Transacional(readonly=true)을 클래스에 사용 시 모든 메소드가 읽기 전용으로 동작한다. 쓰기에 필요한 lock이나 기타 부가 작업을 생략하기 때문에 우리가 느끼지는 못하지만 추가, 삭제, 수정까지 전체 허용하는 것 보다 성능이 최적화된다. 필요한 경우 내부 메소드에 따로 쓰기 작업 메서드를 추가할 수 있다. 

  ---
  ### 17. Java 에서 Annotation 은 어떤 기능을 하나요?  
- 소스 컴파일, 실행 시 컴파일러 및 다른 프로그램에게 필요한 정보를 전달해주는 문법 요소
- 표준 어노테이션 : 자바 기본 제공 어노테이션
  - @override  : 상위 메서드 오버라이드
  - @deprecated : 새 JDK 등장 시 사용하지 않는 필드, 메서드 있는 경우 사용 -> 삭제하기 곤란할 때 표시
  - @suppressWarning : 컴파일 경고 무시 
  - @functionalInterFace : 함수형 인터페이스 선언 시 컴파일러가 바르게 선언되었는지 확인하도록 시키는 것
- 메타 어노테이션 : 다른 어노테이션에서도 사용됨. custom-annotion 생성 시 사용
  - @Override 설정 후 @Target / @Retentaion 같이 부가 기능 정의 어노테이션 
#### 17.2 별 기능이 없는 것 같은데, 어떻게 Spring 에서는 Annotation 이 그렇게 많은 기능을 하는 걸까요
  - 어노테이션이 스프링에게 무슨일을 해야하는지 알려주는 역할을 하기 때문에, 개발자가 의도한 빈 등록(service, component..), 트랜잭션 관리(transactional..) 요청 매핑 등을 빠르게 파악하고 이를 기반으로 어플리케이션 동작을 동적으로 설정할 수 있습니다.

#### 17.3 Lombok의 @Data를 잘 사용하지 않는 이유는 무엇일까요?
  - @Data는 getter, setter, toString 등을 포함하는 종합 어노테이션이다.
  - equals()와 hashcode() 또한 자동으로 생성하여, 값이 변경될 시 불일치 등으로 문제가 발생할 수 있다. 
  - 디버깅이 어려우며 외부 라이브러리에 대한 의존성 + java 버전 호환성 문제 등이 발생할 수 있기 때문이다.

  ---
  ### 18. Tomcat이 정확히 어떤 역할을 하는 도구인가요?
  - 톰캣은 WAS 웹 어플리케이션 서버이다. (Cf.Apache는 SW 회사 이름이고, 웹서버를 말한다)
  - WAS : 클라이언트 요청을 받아 처리하고 응답하는 동적 데이터 처리 서블릿 컨테이너이다. jsp, servlet을 포함한다.

  #### 18.2 혹시 Netty에 대해 들어보셨나요? 왜 이런 것을 사용할까요? 
  - 생성배경
    - 기존 소켓 프로그램은 클라이언트 접속시 스레드를 할당 -> 많은 클라이언트 -> 스레드 생성 -> 리소스 낭비
    - NIO(Non-Blocking Input Output) 방식 개발 등장 - 비동기적 네트워크 통신
    - 클라이언트 당 스레드 생성이 아닌 필요할 때마다 스레드에 통지를 해 생성하는 비동기적 통신 구조
    -> 적은 수의 스레드로 더 많은 커넥션을 취할 수 있어서 메모리 관리가 쉽고, 오버헤드가 줄어들고, 잉여 스레드는 다른 작업에 할당 가능 -> Netty 프레임워크를 사용하면 쉽게 구축 가능
  - Netty란
    - 비동기 이벤트 기반 네트워크 어플리케이션 프레임워크 -> 많은 수의 클라이언트 동시 처리 가능
    - 소켓 모드 상관 없이(다양한 프로토콜 지원 Http, Https, Websocket, Ftp..) 개발할 수 있도록 추상화된 API를 제공하여 데이터 송수신 부분 로직을 고칠 필요가 없다.
    - 안정적이고, 속도가 빠르다.
    - 사용처 : 채팅서버, 게임서버 등
      























