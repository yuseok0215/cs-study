## 📚 1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.
OS에 종속받지 않고 CPU가 Java를 인식하고 실행할 수 있게 하는 가상 컴퓨터입니다. 즉, JVM만 있으면 운영체제가 리눅스든, 맥이든 관계 없이 운영체제로부터 독립적으로 프로그램을 제약 없이 실행할 수 있다는 의미입니다. 그렇게 할 수 있는 이유는 컴파일된 코드와 하드웨어 및 OS 사이 중간에서 해당 하드웨어와 OS 환경에 알맞게 JVM이 Byte Code에서 Binary Code로 변환해주기 때문입니다.

> 1-1. 그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?

가능합니다. 자바 외에도 JVM의 바이트코드로 컴파일되는 여러 언어가 JVM 위에서 실행될 수 있습니다. 대표적인 예로 자바와 호환이 아주 잘 되는 코틀린이 있습니다. 

> 1-2. 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?

JVM 계열 언어는 일반적으로 JVM에서 실행되도록 설계되었지만, Scala Native와 같은 기술을 활용하면 네이티브 바이너리로 변환하여 JVM 없이 실행할 수 있습니다. 하지만 이 경우에는 리플랙션과 같은 일부 JVM 기능이 제한될 수 있습니다.

> 1-3. VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.

VM을 사용하면 운영체제와 하드웨어와 관계없이 실행이 가능하고, 가비지 컬렉션을 통해 메모리 관리를 자동화하여 메모리 누수를 방지할 수 있지만 네이티브 코드보다 실행 속도가 느릴 수 있고, 메모리 사용량이 증가한다는 점이 있습니다. 또한 프로그램 시작 시 바이트코드를 변환하는 과정이 필요해 초기 실행 속도가 느릴 수 있어 상황에 따라 VM을 활용하는 것이 좋다고 생각합니다.

> 1-4. JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?

일반적으로 JVM과 실행되는 프로그램은 부모-자식 프로세스 관계가 아닙니다. JVM은 하나의 프로세스로 실행되며, 내부에서 동작하는 Java 애플리케이션은 JVM의 쓰레드로 실행됩니다. 
(다만 ProcessBuilder를 사용하여 외부 프로세스를 실행하는 경우에는 JVM이 부모 프로세스가 되고, 실행된 프로그램이 자식 프로세스가 될 수 있습니다.)

## 📚 2. final 키워드를 사용하면, 어떤 이점이 있나요?
불변성을 보장하기 때문에 코드 안정성이 증가합니다. 특히 안전한 공유 객체가 되어 멀티스레드 환경에서 동기화 문제를 줄일 수 있습니다.

> 2-1. 그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?

네, final 키워드는 컴파일러가 다양한 최적화를 수행할 수 있도록 도와줍니다.  final static 변수는 컴파일 타입에 상수 값으로 치환되어 실행 속도가 향상됩니다. 또한 final 클래스의 경우 동적 바인딩 대신 정적 바인딩을 사용할 수 있어 성능 최적화가 가능합니다.

## 📚 3. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.
추상클래스는 상속 받을 클래스들이 공통으로 가지는 메서드와 필드가 많아 중복 멤버 통합이 필요할 때 사용합니다. 인터페이스는 어플리케이션의 기능을 정의해야 하지만 그 구현 방식이나 대상에 대해 추상화 할 때 사용합니다. 즉, 추상클래스는 공통 기능을 제공하여 재사용성을 높이고, 인터페이스는 클래스와 별도로 구현 개체가 같은 동작을 한다는 것을 보장합니다.

> 3-1. 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?

두 개이상의 클래스에서 상속받는 경우 상속하는 각 클래스에서 같은 메서드가 구현되어 있을 때 자식클래스에 어떤 메서드를 상속받아야 하는지 모호해지는 다이아몬드 문제가 발생할 수 있습니다. 반면에 인터페이스의 경우 다중 구현이 가능한 이유는 메스드 구현을 강제하지만, 메서드의 구현은 자식 클래스가 담당하기 때문입니다. 

## 📚 4. 리플렉션에 대해 설명해 주세요.
자바 리플랙션은 실행 시간에 클래스, 메서드, 필드 등의 정보를 동적으로 조회하고 조작할 수 있는 기능입니다. 이를 통해 컴파일 시점이 아닌 실행 시점에서 객체의 구조를 분석하고 변경할 수 있습니다.

> 4-1. 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?

네. 리플랙션은 보안적인 문제를 유발할 수 있습니다. 특히 setAccessible(true)를 통해 private 필드나 메서드에 접근할 수 있는 문제가 있습니다. 방지하는 방법으로는 가능하면 정적 코드를 사용하여 리플랙션 의존도를 줄이는 것과 화이트리스트 검증을 활용하는 것이 있습니다.

> 4-2. 리플렉션을 언제 활용할 수 있을까요?

보통 리플랙션은 애플리케이션 개발에서보다는 프레임워크, 라이브러리에서 많이 사용됩니다. 왜냐하면 프레임웤, 라이브러리는 사용하는 사람이 어떤 클래스명과 멤버를 구성할지 모르는데, 이러한 사용자 클래스들은 기존의 기능과 동적으로 연결시키기 위해 리플랙션을 사용한다. 대표적으로 스프링의 DI, Proxy 등이 있습니다.

## 📚 5. static class와 static method를 비교해 주세요.
`static class` 는 주로 내부 클래스에서 사용되며, 외부 클래스의 인스턴스 없이 독립적으로 동작할 수 있도록 합니다. 반면, `static method` 는 특정 객체가 아닌 클래스 자체에서 호출할 수 있는 메서드로, 주로 유틸리티 함수나 공통 기능을 구현하는 데 사용됩니다.

두 개 모두 인스턴스 없이 호출 가능하지만, `static class` 는 클래스 정의를 위한 것이고, `static method` 는 특정 동작을 수행하는 차이가 있습니다.

> 5-1. static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?

static을 사용하면 객체를 생성하지 않고도 멤버에 접근할 수 있어 메모리 최적화와 성능 향상의 이점이 있습니다. 하지만 static으로 선언된 인스턴스, 변수, 메서드는 JVM의 heap 영역이 아닌 method area에 저장되고 GC의 대상이 아니므로 메모리 누수 가능성이 있습니다.

> 5-2. 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.

컴파일 단계에서 .class 파일에 static 멤버가 존재하면, 객체 생성 없이도 접근 가능하도록 바이트 코드가 생성됩니다. JVM이 실행될 때는 Method Area에 static 멤버가 저장되고 런타임 시에 static 멤버는 객체 생성과 관계없이 접근이 가능합니다.
