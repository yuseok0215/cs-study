## 📚 1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.
OS에 종속받지 않고 CPU가 Java를 인식하고 실행할 수 있게 하는 가상 컴퓨터입니다. 즉, JVM만 있으면 운영체제가 리눅스든, 맥이든 관계 없이 운영체제로부터 독립적으로 프로그램을 제약 없이 실행할 수 있다는 의미입니다. 그렇게 할 수 있는 이유는 컴파일된 코드와 하드웨어 및 OS 사이 중간에서 해당 하드웨어와 OS 환경에 알맞게 JVM이 Byte Code에서 Binary Code로 변환해주기 때문입니다.

> 1-1. 그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?

가능합니다. 자바 외에도 JVM의 바이트코드로 컴파일되는 여러 언어가 JVM 위에서 실행될 수 있습니다. 대표적인 예로 자바와 호환이 아주 잘 되는 코틀린이 있습니다. 

> 1-2. 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?

JVM 계열 언어는 일반적으로 JVM에서 실행되도록 설계되었지만, Scala Native와 같은 기술을 활용하면 네이티브 바이너리로 변환하여 JVM 없이 실행할 수 있습니다. 하지만 이 경우에는 리플랙션과 같은 일부 JVM 기능이 제한될 수 있습니다.

> 1-3. VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.

VM을 사용하면 운영체제와 하드웨어와 관계없이 실행이 가능하고, 가비지 컬렉션을 통해 메모리 관리를 자동화하여 메모리 누수를 방지할 수 있지만 네이티브 코드보다 실행 속도가 느릴 수 있고, 메모리 사용량이 증가한다는 점이 있습니다. 또한 프로그램 시작 시 바이트코드를 변환하는 과정이 필요해 초기 실행 속도가 느릴 수 있어 상황에 따라 VM을 활용하는 것이 좋다고 생각합니다.

> 1-4. JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?

일반적으로 JVM과 실행되는 프로그램은 부모-자식 프로세스 관계가 아닙니다. JVM은 하나의 프로세스로 실행되며, 내부에서 동작하는 Java 애플리케이션은 JVM의 쓰레드로 실행됩니다. 
(다만 ProcessBuilder를 사용하여 외부 프로세스를 실행하는 경우에는 JVM이 부모 프로세스가 되고, 실행된 프로그램이 자식 프로세스가 될 수 있습니다.)

## 📚 2. final 키워드를 사용하면, 어떤 이점이 있나요?
불변성을 보장하기 때문에 코드 안정성이 증가합니다. 특히 안전한 공유 객체가 되어 멀티스레드 환경에서 동기화 문제를 줄일 수 있습니다.

> 2-1. 그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?

네, final 키워드는 컴파일러가 다양한 최적화를 수행할 수 있도록 도와줍니다.  final static 변수는 컴파일 타입에 상수 값으로 치환되어 실행 속도가 향상됩니다. 또한 final 클래스의 경우 동적 바인딩 대신 정적 바인딩을 사용할 수 있어 성능 최적화가 가능합니다.

## 📚 3. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.
추상클래스는 상속 받을 클래스들이 공통으로 가지는 메서드와 필드가 많아 중복 멤버 통합이 필요할 때 사용합니다. 인터페이스는 어플리케이션의 기능을 정의해야 하지만 그 구현 방식이나 대상에 대해 추상화 할 때 사용합니다. 즉, 추상클래스는 공통 기능을 제공하여 재사용성을 높이고, 인터페이스는 클래스와 별도로 구현 개체가 같은 동작을 한다는 것을 보장합니다.

> 3-1. 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?

두 개이상의 클래스에서 상속받는 경우 상속하는 각 클래스에서 같은 메서드가 구현되어 있을 때 자식클래스에 어떤 메서드를 상속받아야 하는지 모호해지는 다이아몬드 문제가 발생할 수 있습니다. 반면에 인터페이스의 경우 다중 구현이 가능한 이유는 메스드 구현을 강제하지만, 메서드의 구현은 자식 클래스가 담당하기 때문입니다. 

## 📚 4. 리플렉션에 대해 설명해 주세요.
자바 리플랙션은 실행 시간에 클래스, 메서드, 필드 등의 정보를 동적으로 조회하고 조작할 수 있는 기능입니다. 이를 통해 컴파일 시점이 아닌 실행 시점에서 객체의 구조를 분석하고 변경할 수 있습니다.

> 4-1. 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?

네. 리플랙션은 보안적인 문제를 유발할 수 있습니다. 특히 setAccessible(true)를 통해 private 필드나 메서드에 접근할 수 있는 문제가 있습니다. 방지하는 방법으로는 가능하면 정적 코드를 사용하여 리플랙션 의존도를 줄이는 것과 화이트리스트 검증을 활용하는 것이 있습니다.

> 4-2. 리플렉션을 언제 활용할 수 있을까요?

보통 리플랙션은 애플리케이션 개발에서보다는 프레임워크, 라이브러리에서 많이 사용됩니다. 왜냐하면 프레임웤, 라이브러리는 사용하는 사람이 어떤 클래스명과 멤버를 구성할지 모르는데, 이러한 사용자 클래스들은 기존의 기능과 동적으로 연결시키기 위해 리플랙션을 사용한다. 대표적으로 스프링의 DI, Proxy 등이 있습니다.

## 📚 5. static class와 static method를 비교해 주세요.
`static class` 는 주로 내부 클래스에서 사용되며, 외부 클래스의 인스턴스 없이 독립적으로 동작할 수 있도록 합니다. 반면, `static method` 는 특정 객체가 아닌 클래스 자체에서 호출할 수 있는 메서드로, 주로 유틸리티 함수나 공통 기능을 구현하는 데 사용됩니다.

두 개 모두 인스턴스 없이 호출 가능하지만, `static class` 는 클래스 정의를 위한 것이고, `static method` 는 특정 동작을 수행하는 차이가 있습니다.

> 5-1. static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?

static을 사용하면 객체를 생성하지 않고도 멤버에 접근할 수 있어 메모리 최적화와 성능 향상의 이점이 있습니다. 하지만 static으로 선언된 인스턴스, 변수, 메서드는 JVM의 heap 영역이 아닌 method area에 저장되고 GC의 대상이 아니므로 메모리 누수 가능성이 있습니다.

> 5-2. 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.

컴파일 단계에서 .class 파일에 static 멤버가 존재하면, 객체 생성 없이도 접근 가능하도록 바이트 코드가 생성됩니다. JVM이 실행될 때는 Method Area에 static 멤버가 저장되고 런타임 시에 static 멤버는 객체 생성과 관계없이 접근이 가능합니다.

## 📚 6. Java의 Exception에 대해 설명해 주세요.
Exception은 프로그램 실행 중에 발생할 수 있는 오류 상황을 처리하기 위한 Java의 메커니즘입니다.

> 6-1. 예외처리를 하는 세 방법에 대해 설명해 주세요.

첫 번째는 예외 상황을 파악하고 문제를 해결해서 정상 상태로 되돌려놓은 예외 복구가 있습니다. 예외가 발생하더라도 일정 수만큼 재시도를 하여 예외 복구를 시도합니다. 

두 번째는 예외 처리를 직접 담당하지 않고 호출한 쪽으로 던져 회피하는 예외 처리 회피 방법입니다. 호출한 쪽에서 예외를 처리하는 것이 바람직 할 때 사용합니다. 

세 번째는 회피 방법과 비슷하게 메서드 밖으로 예외를 던지지만, 좀 더 명확한 의미를 가진 예외로 변경해서 예외를 던지는 것입니다.

> 6-2. CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.

언체크 예외와 체크 예외의 차이점은 예외처리를 강제하는지, 안하는지에 있습니다.

체크 예외는 복구 가능성이 있는 예외이므로 반드시 예외를 처리하는 코드를 함께 작성합니다. 대표적으로 IOException, SQLException 등이 있으며, 예외를 처리하지 않으면 컴파일 에러가 발생합니다.
RuntimeException 클래스를 상속받는 언체크 예외 클래스들은 복구 가능성이 없는 예외들이므로 컴파일러가 예외 처리를 강제하지 않습니다. 에러를 처리하지 않아도 컴파일 에러가 발생하지 않고, 런타임 예외는 예상치 못한 상황에서 발생하는 것이 아니므로 굳이 예외 처리를 강제하지 않습니다.

> 6-3. 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?

네. 예외처리가 자주 발생하면 스택 트레이스를 캡처하고 객체를 생성하는 과정에서 성능에 영향을 미칠 수 있습니다. 따라서 예외를 정상적인 제어 흐름으로 사용하는 것이 중요합니다. 그러기 위해서 입력 값을 사전에 검증하여 예외 발생을 최소화해야 합니다. 또한 예외 객체를 캐싱하여 재사용하는 방법도 있을 것 같습니다.

## 📚 7. Synchronized 키워드에 대해 설명해 주세요.
Sychronized 키워드는 자바에서 멀티스레드 환경에서 동기화를 보장하기 위해 사용하는 키워드입니다. 이때 공유자원은 여러 스레드가 동시에 접근하지 못하도록 락을 걸어 데이터 일관성을 유지합니다.

> 7-1. Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.

총 4가지가 있는데, synchronized method는 인스턴스 단위로 lock을 걸지만, synchronized 키워드가 붙은 메소드들에 대해서만 lock을 공유한다. 즉, synchronized 메소드를 호출하는 순간, 모든 synchronized 메소드에 lock이 걸려 다른 스레드가 어떠한 Sychronized 메소드를 호출할 수 없다. 여기에 static이 추가되면 인스턴스가 아닌 클래스 단위로 lock을 공유합니다. 이때 인스턴스 단위에 거는 lock은 공유가 되지 않아 동기화 이슈가 발생할 수 있다.

sychronized block은 sychronized 인자 값으로 this를 사용하면 block을 통해 만들어진 스레드는 lock을 공유합니다. 여기에 static이 추가되면 클래스 단위로 lock을 공유합니다.

> 7-2. 효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?

멀티스레드 환경에서 데이터 정합성을 유지해야 하는 상황이라면 좋은 키워드라고 생각합니다. 다만 sychronized는 락을 획득하고 해제하는 과정에서 성능 저하가 발생할 수 있고, 특히 경합 상태에서 병목이 심해지는 경향이 있습니다. 또한 단순한 읽기 작업에서도 불필요한 lock이 적용된다면 속도 저하가 발생하기 때문에 상황에 맞게 사용해야 합니다. 이외에 스레드 대기, 데드락과 같은 위험성도 존재합니다.

> 7-3. Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.

Concurrent Collections을 활용한 방법이 있습니다. 이를 통해 멀티스레드 환경에서 안전한 컬렉션 관리를 수행할 수 있으며, 읽기와 쓰기 병행 작업이 많을 때 synchronized 보다 효율적입니다. 또 Atomic 패키지를 활용하여 thread-safe한 연산을 수행할 수 있습니다.

> 7-4. Thread Local에 대해 설명해 주세요.

Thread Local은 Java에서 지원하는 Thread Safe한 기술로 멀티 스레드 환경에서 각각의 스레드가 개별적으로 데이터를 저장하고 관리할 수 있도록 도와줍니다. 즉, 스레드별로 독립적인 변수를 유지할 수 있도록 해주며, 멀티스레드 환경에서도 데이터 충돌 없이 안전하게 사용할 수 있습니다.

다만 WAS 환경에서는 Thread pool 기반으로 동작하기 때문에 Thread Local을 사용할 때 사용 후에 비워주지 않는다면 해당 Thread를 부여받는 다른 사용자가 기존에 세팅된 Thread Locald의 데이터를 공유할 수 있습니다. 그렇기에, Thread의 사용이 끝나는 시점에 Thread Local을 초기화시킬 필요가 있습니다.

## 📚 8. Java Stream에 대해 설명해 주세요.
먼저 자바는 크게 명령형 프로그래밍으로 분류됩니다. Java를 이용해 함수형으로 프로그래밍할 수 있도록 JDK8부터 Stream API와 람다식, 함수형 인터페이스 등을 지원하면서  API를 제공합니다. 자바 스트림은 데이터를 추상화하고, 처리하는데 자주 사용되는 함수들을 정의해뒀습니다.

> 8-1. Stream과 for ~ loop의 성능 차이를 비교해 주세요

일반적으로 Stream이 for loop보다 더 느립니다. for loop는 개념 자체가 나온지 이미 오래됐고, 그에 따라 JVM 내부에서 최적화가 잘 되어 있기 때문에 java8과 함께 출시된 Stream 보다 빠릅니다. 또한 원시타입의 경우 for loop가 압도적으로 빠른 편이고 ArrayList와 같은 참조 데이터의 경웨도 for loop가 더 빠르지만 크게 차이가 나진 않습니다.

> 8-2. Stream은 병렬처리 할 수 있나요?

네, 병렬처리를 할 수 있습니다. 내부적으로 Fork와 Join Framework를 사용하여 병렬 처리를 진행하며 개발자가 직접 스레드나 스레드 풀을 생성 및 관리하지 않고 메서드로 간단하게 병렬처리를 진행할 수 있습니다.

> 8-3. Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.

총 4가지의 함수형 인터페이스가 있습니다. 

먼저 Predicate<T>의 경우 주어진 입력을 받아 true 또는 false를 반환하는 인터페이스입니다.    

두번째로 Funtion<T>의 경우 입력을 받아 다른 타입의 출력을 반환하는 함수형 인터페이스

세번째로 Supplier<T>의 경우 매개변수 없이 값을 반환해주는 인터페이스이고,

마지막으로 Consumer<T>의 경우는 입력을 받아 처리하지만 반환값이 없는 인터페이스입니다.

> 8-4. 가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?

스트림 내에서 외부 변수를 사용할 때 final 키워드를 붙이는 이유는 자바의 람다와 클래스 내부에서 변수의 값이 유지되어야 하기 때문입니다. 중간에 외부 변수가 변경되면, 람다가 실행될 때 원래 변수와 캡처된 값이 다를 수 있어 정확하지 않는 값이 반환될 수 있습니다.

또한 final을 쓰지 않아도 자바 8 이후부터는 생략해도 무방하지만 final을 명시함으로써 코드를 유지보수하는 측면에서 실수로 변수를 변경하는 것을 방지할 수 있습니다.

## 📚 9. Java의 GC에 대해 설명해 주세요.
가비지 컬렉션은 자바의 메모리 관리 방법 중의 하나로 JVM의 Heap 영역에서 동적으로 할당했던 메모리 중 필요 없게 된 메모리 객체를 모아 주기적으로 제거하는 프로세스를 말합니다.

> 9-1. finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?

finalize()는 GC가 객체를 삭베하기 전에 호출하는 메서드입니다. 먼저 여전히 참조되고 있는 객체에 finalize()를 호출하면 GC가 이를 수집하지 않으려하여 정상적으로 호출되지 않습니다. 또한 객체를 finalize()에 의해 다시 참조하게 되면 예상치 못하게 객체가 다시 살아날 수 있습니다.

> 9-2. 어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?

네, 상황에 따라 GC가 될 가능성이 있습니다. 보통 변수의 값 또는 객체 자체가 null이 되었고, 다른 참조가 없다면 GC의 대상이 됩니다. 반면에 null이 되었지만 다른 변수 또는 객체가 여러 개의 참조를 가지고 있다면 GC의 대상이 되지 않습니다.

## 📚 10. equals()와 hashcode()에 대해 설명해 주세요. (보완 필요)
equals()는 객체 간 논리적 동등성을 비교하는 메서드입니다. 기본적으로 Object 클래스의 equals() 메서드는 ‘==’ 연산자와 동일하게 참조 비교를 수행합니다. 그래서 객체 내용을 비교하려면 equals()를 오버라이딩해야 합니다.

hashCode()는 객체의 해시 값을 반환하는 메서드로, HashMap, HashSet, HashTable 등에서 사용됩니다. equals()가 참인 객체들은 반드시 hashCode()도 동일한 값을 반환해야 합니다.

> 10-1. 본인이 hashcode() 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?

equals()와의 일관성을 유지할 수 있도록 equals()가 true를 반환한 경우 hashCode()도 동일해야 한다는 것입니다. 객체가 변하였을 때 해시 값도 변하지 않도록 고려하여 작성할 것 같습니다.

> 10-2. 그렇다면 equals() 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.

객체의 논리적 동등성을 정의하고 hashCode()와 일관성을 유지합니다. 그리고 equals()를 구현할 때, 널포인터 예외를 방지해야 합니다.

## 📚 11. IoC와 DI에 대해 설명해 주세요.
IoC는 제어의 역전으로 객체의 생성과 제어 흐름을 개발자가 직접 관리하는 것이 아니라, 프레임워크 또는 컨테이너에 위임한다는 개념입니다. 즉, 객체의 생성, 초기화, 생명 주기 관리 등을 프레임워크가 처리합니다.

DI는 의존성을 직접 생성하지 않고, 외부에서 주입받는 방식입니다. DI는 방금 설명드렸던 IoC의 구현 방식 중 하나이며, 객체 간의 결합도를 낮추고 유지보수를 쉽게 만들어 줍니다. DI는 생성자 주입, 필드 주입, setter 주입이 있는데 각 특징에 대해 간단히 설명드리겠습니다. 

생성자 주입은 객체가 생성될 때 불변성을 유지할 수 있어 가장 권장되는 방식입니다. 필드 주입의 경우, 의존성을 변경하기 어렵고 필드에 직접 접근할 수 없어 테스트가 어렵다는 단점이 있습니다. setter 주입의 경우, 선택적으로 의존성을 주입할 수 있지만 객체 생성 후에 의존성이 주입되므로, 불변성을 보장할 수 없습니다.

> 11-1. 후보 없이 특정 기능을 하는 클래스가 딱 한 개하면, 구체 클래스를 그냥 사용해도 되지 않나요? 그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?

맞습니다. 그런 경우 구체 클래스를 직접 사용해도 된다고 생각합니다. 하지만 Spring에서 여전히 Bean을 등록해서 사용하는 것이 더 좋은 이유가 있습니다. 

먼저 객체가 한 번만 생성되어 재사용되는 싱글톤 빈으로 관리가 되어 불필요한 객체 생성을 방지하고 성능 최적화를 할 수 있습니다. 즉, 하나의 객체를 여러 곳에서 사용해야 한다면, 빈으로 등록하는 것이 훨씬 효율적입니다.

또한 Bean을 사용하면 DI를 통해 코드의 결합도를 낮출 수 있습니다. 그리고 로깅, 트랜잭션과 같은 부가 기능을 쉽게 추가할 수 있습니다.

## 📚 12. AOP에 대해 설명해 주세요.
AOP는 관점 지향 프로그래밍이며, 관점 지향은 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하겠다는 것입니다. 여기서 말하는 핵심적인 관점은 비즈니스를 수행하는 주된 로직을 말하며, 부가적인 관점은 핵심 로직을 실행하기 위해 수행되는 데이터베이스 연결, 로깅, 파일 입출력 등을 예로 들 수 있습니다. 실제 프로젝트를 진행하면서 예외 처리에 대한 if문, 언체크 예외 처리 코드 등이 반복되는 것을 AOP를 활용하여 모듈화하여 처리할 수 있게 개선하여 반복되는 코드를 줄일 수 있었습니다.

> 12-1. @Aspect는 어떻게 동작하나요?

먼저 스프링 애플리케이션에 프록시를 적용하려면 포인트컷과 어드바이스로 구성되어 있는 어드바이저를 만들어서 스프링 빈에 등록하면 됩니다. 자동으로 생성된 프로식 생성기는 스프링 빈으로 어드바이저를 찾고, 스프링 빈들에 자동으로 프록시를 적용해줍니다. 

Aspect 애노테이션은 스프링 어플리케이션이 프록시를 적용할 때 사용되는 어드바이저를 보다 간편하게 포인트컷과 어드바이스로 구성해줍니다. 

실제 동작 과정으로 스프링에서 자동 프록시 생성기를 호출하고, 모든 @Aspect 애노테이션을 보고 어드바이저로 변환해서 저장합니다. 이렇게 생성된 어드바이저를 어드바이저 빈이 조회하고, 조회한 어드바이저에 포함된 포인트컷을 사용해서 프록시 적용 대상인지 아닌지 판단하여 프록시를 생성합니다. 만약 프록시 적용 대상이 아니라면 원본 객체를 반환해서 원본 객체를 스프링 빈으로 등록합니다.

## 📚 13. Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.
인터셉터는 스프링이 제공하는 기술로, 디스패처 서블릿이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공합니다. 즉, 서블릿 컨테이너에서 동작하는 필터와 달리 인터셉터는 스프링 컨텍스트에서 동작합니다. 주로 세부적인 보안 및 인증, 인가 공통 작업이나 API 호출에 대한 로깅 및 감사 작업에 사용하고 추가로 컨트롤러에 넘겨주는 정보를 가공하기도 합니다.

반면에 서블릿 필터는 디스패처 서블릿에 요청이 전달되기 전과 후에 url 패턴에 맞는 모든 요청에 대해 부가작업을 처리할 수 있는 기능을 제공합니다. 인터셉터와 유사하게 쓰이는 부분도 있지만 차이점은 스프링과 분리되어야 하는 기능으로 사용하며 이미지 및 데이터 압축, 문자열 인코딩을 하는 상황에서 많이 쓰입니다.

> 13-1. 설명만 들어보면 인터셉터만 쓰는게 나아보이는데, 아닌가요? 필터는 어떤 상황에 사용 해야 하나요?

상황에 따라 필터는 인터셉터가 처리하는 것보다 더 낮은 레벨의 공통기능을 처리합니다. 예로 인코딩, CORS 등이 있습니다. 또한 인터셉터는 스프링 MVC 컨텍스트 내에서 비즈니스 로직 관련 처리를 담당합니다. 그래서 필터는 보통 서블릿 컨테이너 레벨에서 요청을 가로채고 싶을 때 사용합니다.

대표적으로 필터를 인증과 인가에 사용하는 도구로 Spring Security가 있습니다. Spring Security의 특징 중 하나는 Spring MVC에 종속적이지 않다는 것인데, 이러한 이유로는 필터 기반으로 인증 및 인가 처리를 하기 때문입니다.

## 📚 14. DispatcherServlet 의 역할에 대해 설명해 주세요.
디스패처 서블릿은 HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는 프론트 컨트롤러라고 정의할 수 있습니다. 디스패처 서블릿은 먼저 클라이언트로부터 요청을 받고 요청 정보를 통해 요청을 위임할 컨트롤러를 찾습니다. 이때 컨트롤러는 다양한 코드 작성 방식으로 구현되어 있어 디스패처 서블릿이 직접 컨트롤러에 접근하지 않고 핸들러 어댑터를 거쳐 요청을 보낼 컨트롤러를 찾게 됩니다.

> 14-1. 여러 요청이 들어온다고 가정할 때, DispatcherServlet은 한번에 여러 요청을 모두 받을 수 있나요?

네. 여러 요청을 받을 수 있습니다. 한 요청을 처리하는 도중에 다른 요청이 들어오면 멀티스레드로 요청을 처리할 수 있는데요, 여러 스레드가 생성되고 스레드 당 같은 서블릿이나 다른 서블릿을 통해 여러 요청을 동시에 처리할 수 있습니다. 하지만 스레드를 생성하는 것 자체가 큰 비용이고 다른 스레드로 전환하는 컨텍스트 스위치가 많은 오버헤드를 야기할 수 있기 때문에 멀티스레딩을 자주 사용할 때 주의해야 합니다. 그래서 서버의 하드웨어를 고려하여 스레드 최대 생성 개수를 제한해 두는 방식으로 적절하게 사용해야 합니다.

> 14-2. 수많은 @Controller 를 DispatcherServlet은 어떻게 구분 할까요?

먼저 디스패처 서블릿이 모든 요청을 받고, 핸들러 매핑이 요청을 처리할 때 매핑된 컨트롤러를 찾아서 반환합니다. 이렇게 찾은 컨트롤러를 핸들러 어댑터가 해당 컨트롤러의 메서드를 호출하여 처리 로직을 수행하게 됩니다. 이후 반환받은 값을 디스패처 서블릿이 뷰 리졸버 또는 HTTPMessageConverter를 통해 HTML 또는 JSON 등으로 변환하여 클라이언트에 응답합니다.

## 📚 15. JPA와 같은 ORM을 사용하는 이유가 무엇인가요?
먼저 ORM은 개발자들에게 직관적이며, 개발 생산성과 유지 보수의 편리성을 목적으로 사용됩니다. 개발자가 원시 SQL 쿼리를 작성하는 대신 OOP 개념을 사용하여 데이터베이스와 상호 작용할 수 있도록 하는 프로그래밍 기술입니다. 즉, 객체와 데이터베이스를 매핑해주는 것입니다.

> 15-1. 영속성은 어떤 기능을 하나요? 이게 진짜 성능 향상에 큰 도움이 되나요?
    
영속성은 어플리케이션과 DB 사이에 객체를 보관하는 가상의 DB입니다. EntityManager을 통해 Entity를 영속성 컨텍스트에 보관하고 관리합니다. 영속성 컨텍스트에서는 1차 캐시가 존재하기 때문에 특정 조회 쿼리에서 DB까지 접근하지 않고 캐싱된 데이터를 가져오기 때문에 성능적인 장점이 있습니다. 그리고 한 트랜잭션 내에서 DB에 보낼 쿼리문을 저장했다가 트랜잭션이 끝나기 전 또는 EntityManager가 플러시를 할 때 한번에 쿼리문을 보내는 쓰기지연을 통해 네트워크 부하를 줄일 수 있습니다.

> 15-2. N + 1 문제에 대해 설명해 주세요.

N+1 문제는 ORM 기술에서 특정 객체를 대상으로 수행한 객체가 가지고 있는 연관관계 또한 조회하게 되어 N번의 추가적인 쿼리가 발생하는 문제를 말합니다. N+1 문제가 발생하는 근본적인 원인은 관계형 데이터베이스와 객체지향 언어간의 패러다임 차이로 인해 발생합니다. 객체는 연관관계를 통해 레퍼런스를 가지고 있음녀 언제든지 메모리 내에서 랜덤 엑세스를 통해 연관 객체에 접근할 수 있지만 RDB의 경우 Select 쿼리를 통해서만 조회할 수 있기 때문입니다. 그래서 이 문제를 해결하기 위해 Fetch join과 지연 로딩을 사용합니다. 패치 조인은 루트 엔티티에 대해 조회할 때 지연 로딩으로 설정되어 있는 연관관계를 Join쿼리를 발생시켜 한번에 조회할 수 있는 기능입니다.

## 📚 16. @Transactional 은 어떤 기능을 하나요?
트랜잭션 애노테이션은 트랜잭션 처리를 위해 스프링에서 정의한 선언적 트랜잭션입니다. 해당 애노테이션이 붙은 모듈 내에서 여러 DB와의 작업을 하나의 트랜잭션으로 보장합니다.

> 16-1. @Transactional(readonly=true) 는 어떤 기능인가요? 이게 도움이 되나요?

영속성 컨텍스트는 Entity를 조회할 때 초기 상태에 대한 스냅샷을 저장합니다. 트랜잭션이 커밋될 때, 최기 상태의 정보를 가지는 스냅샷과 엔티티의 상태를 비교하여 변경된 내용에 대해 update 쿼리를 생성해 쓰기 지연 저장소에 저장하게 됩니다. 이 후 일괄적으로 플러시를 통해 쿼리를 업데이트하여 엔티티의 수정이 이뤄집니다. 
    
이 때 readonly 설정을 true로 해주면 트랜잭션 내에서 강제로 플러시를 호출하지 않는 한, 수정 내역에 대해 DB에 적용되지 않습니다. 이로 인해 트랜잭션 커밋 시 영속성 컨텍스트가 자동으로 플러시되지 않으므로 조회용으로 가져온 엔티티에 예상치 못한 수정을 방지할 수 있게 됩니다. 또한 JPA가 해당 트랜잭션내에서 조회하는 엔티티가 조회용임을 인식하고 변경감지를 위한 스냅샷을 따로 보관하지 않으므로 메모리가 절약되는 성능상 이점이 존재합니다.

> 16-2. 그런데, 읽기에 트랜잭션을 걸 필요가 있나요? @Transactional을 안 붙이면 되는거 아닐까요?

조회 작업에 트랜잭션을 걸지 않으면 영속성 컨텍스트를 뷰까지 열어두는 기능인 OSIV가 오프된다. 그래서 영속성 컨텍스트로 관리되는 엔티티가 트랜잭션의 범위를 벗어나는 순간 준영속 상태가 되기 때문에 지연 로딩이 불가합니다.
