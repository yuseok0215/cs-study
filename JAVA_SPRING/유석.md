## 📚 1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.
OS에 종속받지 않고 CPU가 Java를 인식하고 실행할 수 있게 하는 가상 컴퓨터입니다. 즉, JVM만 있으면 운영체제가 리눅스든, 맥이든 관계 없이 운영체제로부터 독립적으로 프로그램을 제약 없이 실행할 수 있다는 의미입니다. 그렇게 할 수 있는 이유는 컴파일된 코드와 하드웨어 및 OS 사이 중간에서 해당 하드웨어와 OS 환경에 알맞게 JVM이 Byte Code에서 Binary Code로 변환해주기 때문입니다.

> 1-1. 그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?

가능합니다. 자바 외에도 JVM의 바이트코드로 컴파일되는 여러 언어가 JVM 위에서 실행될 수 있습니다. 대표적인 예로 자바와 호환이 아주 잘 되는 코틀린이 있습니다. 

> 1-2. 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?

JVM 계열 언어는 일반적으로 JVM에서 실행되도록 설계되었지만, Scala Native와 같은 기술을 활용하면 네이티브 바이너리로 변환하여 JVM 없이 실행할 수 있습니다. 하지만 이 경우에는 리플랙션과 같은 일부 JVM 기능이 제한될 수 있습니다.

> 1-3. VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.

VM을 사용하면 운영체제와 하드웨어와 관계없이 실행이 가능하고, 가비지 컬렉션을 통해 메모리 관리를 자동화하여 메모리 누수를 방지할 수 있지만 네이티브 코드보다 실행 속도가 느릴 수 있고, 메모리 사용량이 증가한다는 점이 있습니다. 또한 프로그램 시작 시 바이트코드를 변환하는 과정이 필요해 초기 실행 속도가 느릴 수 있어 상황에 따라 VM을 활용하는 것이 좋다고 생각합니다.

> 1-4. JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?

일반적으로 JVM과 실행되는 프로그램은 부모-자식 프로세스 관계가 아닙니다. JVM은 하나의 프로세스로 실행되며, 내부에서 동작하는 Java 애플리케이션은 JVM의 쓰레드로 실행됩니다. 
(다만 ProcessBuilder를 사용하여 외부 프로세스를 실행하는 경우에는 JVM이 부모 프로세스가 되고, 실행된 프로그램이 자식 프로세스가 될 수 있습니다.)

## 📚 2. final 키워드를 사용하면, 어떤 이점이 있나요?
불변성을 보장하기 때문에 코드 안정성이 증가합니다. 특히 안전한 공유 객체가 되어 멀티스레드 환경에서 동기화 문제를 줄일 수 있습니다.

> 2-1. 그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?

네, final 키워드는 컴파일러가 다양한 최적화를 수행할 수 있도록 도와줍니다.  final static 변수는 컴파일 타입에 상수 값으로 치환되어 실행 속도가 향상됩니다. 또한 final 클래스의 경우 동적 바인딩 대신 정적 바인딩을 사용할 수 있어 성능 최적화가 가능합니다.

## 📚 3. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.
추상클래스는 상속 받을 클래스들이 공통으로 가지는 메서드와 필드가 많아 중복 멤버 통합이 필요할 때 사용합니다. 인터페이스는 어플리케이션의 기능을 정의해야 하지만 그 구현 방식이나 대상에 대해 추상화 할 때 사용합니다. 즉, 추상클래스는 공통 기능을 제공하여 재사용성을 높이고, 인터페이스는 클래스와 별도로 구현 개체가 같은 동작을 한다는 것을 보장합니다.

> 3-1. 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?

두 개이상의 클래스에서 상속받는 경우 상속하는 각 클래스에서 같은 메서드가 구현되어 있을 때 자식클래스에 어떤 메서드를 상속받아야 하는지 모호해지는 다이아몬드 문제가 발생할 수 있습니다. 반면에 인터페이스의 경우 다중 구현이 가능한 이유는 메스드 구현을 강제하지만, 메서드의 구현은 자식 클래스가 담당하기 때문입니다. 

## 📚 4. 리플렉션에 대해 설명해 주세요.
자바 리플랙션은 실행 시간에 클래스, 메서드, 필드 등의 정보를 동적으로 조회하고 조작할 수 있는 기능입니다. 이를 통해 컴파일 시점이 아닌 실행 시점에서 객체의 구조를 분석하고 변경할 수 있습니다.

> 4-1. 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?

네. 리플랙션은 보안적인 문제를 유발할 수 있습니다. 특히 setAccessible(true)를 통해 private 필드나 메서드에 접근할 수 있는 문제가 있습니다. 방지하는 방법으로는 가능하면 정적 코드를 사용하여 리플랙션 의존도를 줄이는 것과 화이트리스트 검증을 활용하는 것이 있습니다.

> 4-2. 리플렉션을 언제 활용할 수 있을까요?

보통 리플랙션은 애플리케이션 개발에서보다는 프레임워크, 라이브러리에서 많이 사용됩니다. 왜냐하면 프레임웤, 라이브러리는 사용하는 사람이 어떤 클래스명과 멤버를 구성할지 모르는데, 이러한 사용자 클래스들은 기존의 기능과 동적으로 연결시키기 위해 리플랙션을 사용한다. 대표적으로 스프링의 DI, Proxy 등이 있습니다.

## 📚 5. static class와 static method를 비교해 주세요.
`static class` 는 주로 내부 클래스에서 사용되며, 외부 클래스의 인스턴스 없이 독립적으로 동작할 수 있도록 합니다. 반면, `static method` 는 특정 객체가 아닌 클래스 자체에서 호출할 수 있는 메서드로, 주로 유틸리티 함수나 공통 기능을 구현하는 데 사용됩니다.

두 개 모두 인스턴스 없이 호출 가능하지만, `static class` 는 클래스 정의를 위한 것이고, `static method` 는 특정 동작을 수행하는 차이가 있습니다.

> 5-1. static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?

static을 사용하면 객체를 생성하지 않고도 멤버에 접근할 수 있어 메모리 최적화와 성능 향상의 이점이 있습니다. 하지만 static으로 선언된 인스턴스, 변수, 메서드는 JVM의 heap 영역이 아닌 method area에 저장되고 GC의 대상이 아니므로 메모리 누수 가능성이 있습니다.

> 5-2. 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.

컴파일 단계에서 .class 파일에 static 멤버가 존재하면, 객체 생성 없이도 접근 가능하도록 바이트 코드가 생성됩니다. JVM이 실행될 때는 Method Area에 static 멤버가 저장되고 런타임 시에 static 멤버는 객체 생성과 관계없이 접근이 가능합니다.

## 📚 6. Java의 Exception에 대해 설명해 주세요.
Exception은 프로그램 실행 중에 발생할 수 있는 오류 상황을 처리하기 위한 Java의 메커니즘입니다.

> 6-1. 예외처리를 하는 세 방법에 대해 설명해 주세요.

첫 번째는 예외 상황을 파악하고 문제를 해결해서 정상 상태로 되돌려놓은 예외 복구가 있습니다. 예외가 발생하더라도 일정 수만큼 재시도를 하여 예외 복구를 시도합니다. 

두 번째는 예외 처리를 직접 담당하지 않고 호출한 쪽으로 던져 회피하는 예외 처리 회피 방법입니다. 호출한 쪽에서 예외를 처리하는 것이 바람직 할 때 사용합니다. 

세 번째는 회피 방법과 비슷하게 메서드 밖으로 예외를 던지지만, 좀 더 명확한 의미를 가진 예외로 변경해서 예외를 던지는 것입니다.

> 6-2. CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.

언체크 예외와 체크 예외의 차이점은 예외처리를 강제하는지, 안하는지에 있습니다.

체크 예외는 복구 가능성이 있는 예외이므로 반드시 예외를 처리하는 코드를 함께 작성합니다. 대표적으로 IOException, SQLException 등이 있으며, 예외를 처리하지 않으면 컴파일 에러가 발생합니다.
RuntimeException 클래스를 상속받는 언체크 예외 클래스들은 복구 가능성이 없는 예외들이므로 컴파일러가 예외 처리를 강제하지 않습니다. 에러를 처리하지 않아도 컴파일 에러가 발생하지 않고, 런타임 예외는 예상치 못한 상황에서 발생하는 것이 아니므로 굳이 예외 처리를 강제하지 않습니다.

> 6-3. 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?

네. 예외처리가 자주 발생하면 스택 트레이스를 캡처하고 객체를 생성하는 과정에서 성능에 영향을 미칠 수 있습니다. 따라서 예외를 정상적인 제어 흐름으로 사용하는 것이 중요합니다. 그러기 위해서 입력 값을 사전에 검증하여 예외 발생을 최소화해야 합니다. 또한 예외 객체를 캐싱하여 재사용하는 방법도 있을 것 같습니다.

## 📚 7. Synchronized 키워드에 대해 설명해 주세요.
Sychronized 키워드는 자바에서 멀티스레드 환경에서 동기화를 보장하기 위해 사용하는 키워드입니다. 이때 공유자원은 여러 스레드가 동시에 접근하지 못하도록 락을 걸어 데이터 일관성을 유지합니다.

> 7-1. Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.

총 4가지가 있는데, synchronized method는 인스턴스 단위로 lock을 걸지만, synchronized 키워드가 붙은 메소드들에 대해서만 lock을 공유한다. 즉, synchronized 메소드를 호출하는 순간, 모든 synchronized 메소드에 lock이 걸려 다른 스레드가 어떠한 Sychronized 메소드를 호출할 수 없다. 여기에 static이 추가되면 인스턴스가 아닌 클래스 단위로 lock을 공유합니다. 이때 인스턴스 단위에 거는 lock은 공유가 되지 않아 동기화 이슈가 발생할 수 있다.

sychronized block은 sychronized 인자 값으로 this를 사용하면 block을 통해 만들어진 스레드는 lock을 공유합니다. 여기에 static이 추가되면 클래스 단위로 lock을 공유합니다.

> 7-2. 효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?

멀티스레드 환경에서 데이터 정합성을 유지해야 하는 상황이라면 좋은 키워드라고 생각합니다. 다만 sychronized는 락을 획득하고 해제하는 과정에서 성능 저하가 발생할 수 있고, 특히 경합 상태에서 병목이 심해지는 경향이 있습니다. 또한 단순한 읽기 작업에서도 불필요한 lock이 적용된다면 속도 저하가 발생하기 때문에 상황에 맞게 사용해야 합니다. 이외에 스레드 대기, 데드락과 같은 위험성도 존재합니다.

> 7-3. Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.

Concurrent Collections을 활용한 방법이 있습니다. 이를 통해 멀티스레드 환경에서 안전한 컬렉션 관리를 수행할 수 있으며, 읽기와 쓰기 병행 작업이 많을 때 synchronized 보다 효율적입니다. 또 Atomic 패키지를 활용하여 thread-safe한 연산을 수행할 수 있습니다.

> 7-4. Thread Local에 대해 설명해 주세요.

Thread Local은 Java에서 지원하는 Thread Safe한 기술로 멀티 스레드 환경에서 각각의 스레드가 개별적으로 데이터를 저장하고 관리할 수 있도록 도와줍니다. 즉, 스레드별로 독립적인 변수를 유지할 수 있도록 해주며, 멀티스레드 환경에서도 데이터 충돌 없이 안전하게 사용할 수 있습니다.

다만 WAS 환경에서는 Thread pool 기반으로 동작하기 때문에 Thread Local을 사용할 때 사용 후에 비워주지 않는다면 해당 Thread를 부여받는 다른 사용자가 기존에 세팅된 Thread Locald의 데이터를 공유할 수 있습니다. 그렇기에, Thread의 사용이 끝나는 시점에 Thread Local을 초기화시킬 필요가 있습니다.
