## 📚 8. 뮤텍스와 세마포어의 차이점은 무엇인가요?
뮤텍스는 동기화 대상이 오직 1개일 때 사용하며, 세마포어는 동기화 대상이 1개 이상일 때 사용합니다. 뮤텍스는 자원(락)을 소유할 수 있고, 책임을 가지는 반면 세마포어는 자원 소유가 불가능합니다.

> 8-1. 이진 세마포어와 뮤텍스의 차이에 대해 설명해 주세요.

뮤텍스와 이진 세마포어의 차이는 뮤텍스의 경우 락을 설정한 프로세스만이 락을 해제할 수 있습니다. 반면 이진 세마포어의 경우 락을 설정한 프로세스와 해제하는 프로세스가 서로 다를 수 있습니다.

> 8-2. Lock을 얻기 위해 대기하는 프로세스들은 Spin Lock 기법을 사용할 수 있습니다. 이 방법의 장단점은 무엇인가요? 단점을 해결할 방법은 없을까요?

먼저 스핀락은 경쟁 상태(Race Condition)에서 락이 반환될 때까지, 즉 임계영역(critical section)에 진입 가능할 때까지 프로세스가 재시도하며 대기하는 상태입니다. 그리고 스핀락은 스레드가 대기 상태로 전환되지 않기 때문에 컨텍스트 스위칭 일어나지 않는특징을 갖고 있습니다.

스핀락의 장점으로는 컨텍스트 스위칭에 필요한 오버헤드를 줄일 수 있으며, 무한 루프를 통해 반복해서 락의 반환여부를 확인하기 때문에 락의 획득이 빠릅니다. 단점으로는 락을 획득할 때까지 무한 루프를 돌기 때문에 CPU에 많은 부하가 걸리는 것이 있습니다. 또한 특정 스레드나 프로세스가 공유 자원을 오랫동안 점유한다면, 다른 스레드들이 대기 상태에 갇힐 수 있습니다.

이를 해결하는 방법으로 스핀 락에 시간 제한을 설정하는 것이 있습니다. 상황에 맞게 락 획득을 시도하는 시간에 제한을 두면 CPU 낭비를 줄이면서, 여전히 락 획득은 빠르게 이점을 가져갈 수 있습니다. 다른 대안으로는 락 점유 시간 자체를 최소화하여 스핀 락의 대기 시간을 줄일 수도 있습니다.

> 8-3. 뮤텍스와 세마포어 모두 커널이 관리하기 때문에, Lock을 얻고 방출하는 과정에서 시스템 콜을 호출해야 합니다. 이 방법의 장단점이 있을까요? 단점을 해결할 수 있는 방법은 없을까요?

OS가 직접 관리하기 때문에 데드락과 같은 상황에 대한 제어가 가능하며 스케줄링에 따라 정확한 락 순서를 보장할 수 있습니다. 또한 커널 락은 프로세스 간 동기화도 지원합니다.

반대로 단점으로는 시스템 콜에 대한 오버헤드가 발생하고 그로 인해 락 획득 및 해제 속도가 느립니다. 그리고 락을 잠깐 사용하는 경우에도 시스템 콜을 매번 호출하기 때문에 비효율적입니다. 해결방안으로는 커널의 개입 없이 사용자 공간에서 락을 관리하여 시스템 콜 오버헤드를 줄이는 방법이 있습니다. 

대표적인 예로 futex매커니즘이 있는데 이것은 사용자 공간에서 대부분의 락 연산을 처리하고, 충돌이 발생했을 때만 커널에 도움을 요청하는 매커니즘입니다. 즉, 락이 비경쟁 상태일 때는 빠르게 처리하고, 경쟁 상태일 때만 커널의 개입을 받습니다. 이러한 접근 방식은 시스템 콜을 최소화하여 성능을 향상시킵니다.

## 📚 9. Deadlock 에 대해 설명해 주세요.
두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 무한히 다음 자원을 기다리게 되는 상태를 말합니다.

> 9-1. Deadlock 이 동작하기 위한 4가지 조건에 대해 설명해 주세요.

먼저 상호 배제로 자원은 한번에 한 프로세스만 사용할 수 있는 조건이고, 점유 대기는 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 하는 조건입니다. 또 비선점은 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없는 조건이며, 마지막으로 순환 대기는 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 한다는 조건입니다.

> 9-2. 그렇다면 3가지만 충족하면 왜 Deadlock 이 발생하지 않을까요?

충족되지 않은 한 조건에 따라 순환구조가 만들어지지 않거나, 자원이 강제로 회수되거나, 기다리는 상황이 없기 때문입니다.

> 9-3. 어떤 방식으로 예방할 수 있을까요?

데드락의 발생조건 4가지 중에서 하나라도 발생하지 않도록 하는 것으로 데드락을 해결할 수 있습니다. 다른 방법으로는 데드락 회피 방법이 있습니다. 특정한 순서로 프로세스들에게 자원을 할당할 때 데드락이 발생하지 않는 순서를 찾을 수 있다면 안전 순서를 통해 방지할 수 있습니다. 

그리고 데드락 탐지 기법을 사용하여 시스템에 데드락이 발생했는지 여부를 탐색하고 순환 대기에서 벗어나는 방법으로 교착 상태에 빠진 프로세스를 중지시키거나 자원을 선점하여 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해주는 방법이 있습니다.

> 9-4. 왜 현대 OS는 Deadlock을 처리하지 않을까요?

데드락을 예방, 회피, 탐지하는 비용이 너무 크고 데드락이 드물게 발생하기 때문에 데드락이 발생했을 때 재시도 혹은 프로세스를 죽이는 것으로도 충분합니다. 그래서 현대 OS는 적극적으로 데드락을 처리하지 않습니다.

> 9-5. Wait Free와 Lock Free를 비교해 주세요.

Lock-Free 알고리즘은 락 없이도 최소한 하나의 스레드는 작업을 완료할 수 있는 것을 보장해줍니다. 이 방식에서는 원자적 연산을 활용하여 자원에 대한 동시 접근을 제어하고 있습니다. 일단 락을 사용하지 않기 때문에 교착상태가 발생하지 않습니다.

Wait-Free 알고리즘은 모든 스레드가 유한한 시간 내에 작업을 완료할 수 있다는 것을 보장합니다. 그래서 lock-free보다 더 강력한 동시성을 보장합니다. 모든 스레드가 일정한 시간 내에 작업을 완료할 수 있도록 설계되어 무한정 대기가 없으며, 주로 원자적 연산을 활용해 경쟁 상태 없이 자원을 안전하게 접근할 수 있습니다.

## 📚 10. 프로그램이 컴파일 되어, 실행되는 과정을 간략하게 설명해 주세요.
컴파일 과정은 4가지 단계로 나누어지는데, 첫번째로 전처리기를 통해 소스 코드 파일을 전처리된 소스 코드 파일로 변환하는 과정인 전처리과정입니다. 두번째로 전처리된 소스 코드 파일을 어셈블리어 파일로 변환하는 과정인 컴파일 과정입니다. 세번째로 어셈블리를 통해 어셈블리어 파일을 오브젝트 파일로 변환하는 어셈블리 과정입니다. 마지막으로 링커를 통해 오브젝트 파일들을 묶어 실행 파일로 만드는 과정인 링킹 과정입니다.

> 10-1. 링커와, 로더의 차이에 대해 설명해 주세요.

링커는 재배치 가능 오브젝트 파일을 하나의 이진 실행 파일로 결합하는 것이고, 로더는 이렇게 결합된 이진 실행 파일을 메모리에 적재하는 것입니다.

> 10-2. 컴파일 언어와 인터프리터 언어의 차이에 대해 설명해 주세요.

컴파일 과정을 거쳐 생성된 기계 코드는 CPU가 직접 실행할 수 있는 형태이며, 반대로 인터프리터는 프로그램 실행 시마다 소스 코드를 기계어로 번역해야 하므로, 성능 지연이 있어 컴파일 언어가 인터프리터 언어에 비해 빠른 실행 속도를 가집니다. 

> 10-3. JIT에 대해 설명해 주세요.

JVM 초기에 실행 시점에 모든 바이트코드를 직접 기계어로 해석했기 때문에 성능 문제가 있었습니다. 이를 위해 런타임에 바이트코드를 느리게 해석하는 대신 JDK 1.3에 HotSpot VM이 도입되어 최적화된 코드를 실행할 수 있게 하는 것이 JIT 컴파일입니다. 

> 10-4. 본인이 사용하는 언어는, 어떤식으로 컴파일 및 실행되는지 설명해 주세요.

자바 컴파일러는 자바 파일을 읽고 클래스 파일로 컴파일합니다. 바이트코드는 모든 연산 코드가 단일 바이트로 표시되며 플랫폼에 종속되지 않는 명령어 집합으로 구성된다. 이들은 자바 가상 머신에서 실행되며 실행 시점에 기계어로 번역 후 실행됩니다.

> 10-5. Python 같은 언어는 CPython, Jython, PyPy등의 다양한 구현체가 있습니다. 각각은 어떤 차이가 있을까요? 또한, 실행되는 과정 또한 다를까요?

CPython은 C로 작성되어 있으며, 소스 코드를 바이트코드로 컴파일한 후 CPython 가상 머신에서 인터프리터 방식으로 실행합니다.

JPython은 Java로 작성되어 있으며 파이썬 코드를 자바 바이트코드로 컴파일하여 JVM에서 실행합니다.

PyPy는 RPython으로 작성되어 있으며, JIT 컴파일러를 사용해 실행 시간에 최적화되어 있습니다.

> 10-6. 우리는 흔히 fork(), exec() 시스템 콜을 사용하여 프로세스를 적재할 수 있다고 배웠습니다. 로더의 역할은 이 시스템 콜과 상관있는 걸까요? 아니면 다른 방식으로 프로세스를 적재할 수 있는 건가요?

네 연관이 있습니다. 먼저 셸은 fork() 시스템 콜을 사용하여 프로그램을 실행하기 위해 새 프로세스를 생성해주고 이후, exec() 시스템 콜로 로더를 호출하고 exec()에 실행 파일 이름을 전달합니다. 로더는 새로 생성된 프로세스의 주소 공간을 사용하여 지정된 프로그램을 메모리에 적재합니다.

## 📚 11. IPC가 무엇이고, 어떤 종류가 있는지 설명해 주세요.
하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신을 Inter Process Communication이라고 부릅니다.

> 11-1. Shared Memory가 무엇이며, 사용할 때 유의해야 할 점에 대해 설명해 주세요.

공유 메모리 방식은 프로세스들이 주소 공간의 일부를 공유하는 방식입니다. 운영체제는 공유 메모리를 사용하는 시스템 콜을 지원해서 서로 다른 프로세스들이 그들의 공간 중 일부를 공유할 수 있도록 합니다.

이로 인해 프로세스간의 통신을 수월하게 만들지만 데이터 공유를 통해 동기화 이슈가 발생할 수 있기 때문에 세마포어를 통해 데이터 접근 동기화를 수행하면 데이터 일관성을 유지할 수 있습니다.

> 11-2. 메시지 큐는 단방향이라고 할 수 있나요?

메시지 큐는 일반적으로 단방향 통신 방식이라고 볼 수 있습니다. 생산자(Producer)가 메시지를 큐에 넣고, 소비자(Consumer)가 그 메시지를 꺼내 처리하는 구조이기 때문에, 생산자에서 소비자 방향으로만 메시지가 흐릅니다.

하지만 이것은 논리적 흐름의 방향에 대한 이야기이고, 양방향 통신이 필요할 경우에도 메시지 큐를 활용할 수 있습니다. 예를 들어, 소비자가 처리 결과를 다시 생산자에게 전달하고 싶다면, 별도의 응답 큐(Response Queue) 를 만들어 사용하는 방식으로 구현할 수 있습니다. 이런 구조를 통해 요청-응답 방식도 메시지 큐로 구현할 수 있지만, 그 자체는 여전히 단방향 큐 두 개를 조합한 것입니다.

즉, 메시지 큐는 본질적으로 단방향이 맞지만, 시스템 아키텍처 설계에 따라 양방향 통신 구조를 만들 수도 있습니다.
