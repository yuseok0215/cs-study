## 📚 8. 뮤텍스와 세마포어의 차이점은 무엇인가요?
뮤텍스는 동기화 대상이 오직 1개일 때 사용하며, 세마포어는 동기화 대상이 1개 이상일 때 사용합니다. 뮤텍스는 자원(락)을 소유할 수 있고, 책임을 가지는 반면 세마포어는 자원 소유가 불가능합니다.

> 8-1. 이진 세마포어와 뮤텍스의 차이에 대해 설명해 주세요.

뮤텍스와 이진 세마포어의 차이는 뮤텍스의 경우 락을 설정한 프로세스만이 락을 해제할 수 있습니다. 반면 이진 세마포어의 경우 락을 설정한 프로세스와 해제하는 프로세스가 서로 다를 수 있습니다.

> 8-2. Lock을 얻기 위해 대기하는 프로세스들은 Spin Lock 기법을 사용할 수 있습니다. 이 방법의 장단점은 무엇인가요? 단점을 해결할 방법은 없을까요?

먼저 스핀락은 경쟁 상태(Race Condition)에서 락이 반환될 때까지, 즉 임계영역(critical section)에 진입 가능할 때까지 프로세스가 재시도하며 대기하는 상태입니다. 그리고 스핀락은 스레드가 대기 상태로 전환되지 않기 때문에 컨텍스트 스위칭 일어나지 않는특징을 갖고 있습니다.

스핀락의 장점으로는 컨텍스트 스위칭에 필요한 오버헤드를 줄일 수 있으며, 무한 루프를 통해 반복해서 락의 반환여부를 확인하기 때문에 락의 획득이 빠릅니다. 단점으로는 락을 획득할 때까지 무한 루프를 돌기 때문에 CPU에 많은 부하가 걸리는 것이 있습니다. 또한 특정 스레드나 프로세스가 공유 자원을 오랫동안 점유한다면, 다른 스레드들이 대기 상태에 갇힐 수 있습니다.

이를 해결하는 방법으로 스핀 락에 시간 제한을 설정하는 것이 있습니다. 상황에 맞게 락 획득을 시도하는 시간에 제한을 두면 CPU 낭비를 줄이면서, 여전히 락 획득은 빠르게 이점을 가져갈 수 있습니다. 다른 대안으로는 락 점유 시간 자체를 최소화하여 스핀 락의 대기 시간을 줄일 수도 있습니다.

> 8-3. 뮤텍스와 세마포어 모두 커널이 관리하기 때문에, Lock을 얻고 방출하는 과정에서 시스템 콜을 호출해야 합니다. 이 방법의 장단점이 있을까요? 단점을 해결할 수 있는 방법은 없을까요?

OS가 직접 관리하기 때문에 데드락과 같은 상황에 대한 제어가 가능하며 스케줄링에 따라 정확한 락 순서를 보장할 수 있습니다. 또한 커널 락은 프로세스 간 동기화도 지원합니다.

반대로 단점으로는 시스템 콜에 대한 오버헤드가 발생하고 그로 인해 락 획득 및 해제 속도가 느립니다. 그리고 락을 잠깐 사용하는 경우에도 시스템 콜을 매번 호출하기 때문에 비효율적입니다. 해결방안으로는 커널의 개입 없이 사용자 공간에서 락을 관리하여 시스템 콜 오버헤드를 줄이는 방법이 있습니다. 

대표적인 예로 futex매커니즘이 있는데 이것은 사용자 공간에서 대부분의 락 연산을 처리하고, 충돌이 발생했을 때만 커널에 도움을 요청하는 매커니즘입니다. 즉, 락이 비경쟁 상태일 때는 빠르게 처리하고, 경쟁 상태일 때만 커널의 개입을 받습니다. 이러한 접근 방식은 시스템 콜을 최소화하여 성능을 향상시킵니다.

## 📚 9. Deadlock 에 대해 설명해 주세요.
두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 무한히 다음 자원을 기다리게 되는 상태를 말합니다.

> 9-1. Deadlock 이 동작하기 위한 4가지 조건에 대해 설명해 주세요.

먼저 상호 배제로 자원은 한번에 한 프로세스만 사용할 수 있는 조건이고, 점유 대기는 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 하는 조건입니다. 또 비선점은 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없는 조건이며, 마지막으로 순환 대기는 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 한다는 조건입니다.

> 9-2. 그렇다면 3가지만 충족하면 왜 Deadlock 이 발생하지 않을까요?

충족되지 않은 한 조건에 따라 순환구조가 만들어지지 않거나, 자원이 강제로 회수되거나, 기다리는 상황이 없기 때문입니다.

> 9-3. 어떤 방식으로 예방할 수 있을까요?

데드락의 발생조건 4가지 중에서 하나라도 발생하지 않도록 하는 것으로 데드락을 해결할 수 있습니다. 다른 방법으로는 데드락 회피 방법이 있습니다. 특정한 순서로 프로세스들에게 자원을 할당할 때 데드락이 발생하지 않는 순서를 찾을 수 있다면 안전 순서를 통해 방지할 수 있습니다. 

그리고 데드락 탐지 기법을 사용하여 시스템에 데드락이 발생했는지 여부를 탐색하고 순환 대기에서 벗어나는 방법으로 교착 상태에 빠진 프로세스를 중지시키거나 자원을 선점하여 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해주는 방법이 있습니다.

> 9-4. 왜 현대 OS는 Deadlock을 처리하지 않을까요?

데드락을 예방, 회피, 탐지하는 비용이 너무 크고 데드락이 드물게 발생하기 때문에 데드락이 발생했을 때 재시도 혹은 프로세스를 죽이는 것으로도 충분합니다. 그래서 현대 OS는 적극적으로 데드락을 처리하지 않습니다.

> 9-5. Wait Free와 Lock Free를 비교해 주세요.

Lock-Free 알고리즘은 락 없이도 최소한 하나의 스레드는 작업을 완료할 수 있는 것을 보장해줍니다. 이 방식에서는 원자적 연산을 활용하여 자원에 대한 동시 접근을 제어하고 있습니다. 일단 락을 사용하지 않기 때문에 교착상태가 발생하지 않습니다.

Wait-Free 알고리즘은 모든 스레드가 유한한 시간 내에 작업을 완료할 수 있다는 것을 보장합니다. 그래서 lock-free보다 더 강력한 동시성을 보장합니다. 모든 스레드가 일정한 시간 내에 작업을 완료할 수 있도록 설계되어 무한정 대기가 없으며, 주로 원자적 연산을 활용해 경쟁 상태 없이 자원을 안전하게 접근할 수 있습니다.
