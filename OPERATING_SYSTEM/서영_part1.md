### 🔍 1. 시스템 콜이 무엇인지 설명해 주세요.
시스템 콜은 응용 프로그램이 운영 체제의 커널 기능을 사용할 수 있도록 제공하는 인터페이스입니다. 
운영 체제는 하드웨어의 자원을 직접 접근할 수 있지만 일반 프로그램은 직접 접근이 불가능하기 때문에 시스템 콜이 필요합니다.
시스템 콜을 통해 커널 모드로 전환해 하드웨어 자원을 사용할 수 있게 됩니다.

#### ❓ 우리가 사용하는 시스템 콜의 예시를 들어주세요.
파일을 열 때 사용하는 open(), 파일을 읽고 쓸 때 read(), write()가 있습니다. 프로세스를 실행시킬 때의 fork(), 
소켓 생성을 위한 socket()도 있습니다.

#### ❓ 시스템 콜이, 운영체제에서 어떤 과정으로 실행되는지 설명해 주세요.
시스템 콜을 호출하면 시스템 콜 번호와 필요한 매개변수를 레지스터에 저장되고 CPU에 인터럽트가 발생해
사용자 모드에서 커널 모드로 전환됩니다. 커널이 레지스터에 저장된 시스템 콜 번호를 읽어 시스템 콜 테이블에서
해당 함수를 찾은 뒤 함수를 실행합니다. 작업이 끝나면 결과 값을 레지스터에 저장하고 커널 모드에서 사용자 모드로 돌아갑니다.

#### ❓시스템 콜의 유형에 대해 설명해 주세요.
프로세스 제어를 위한 fork(), exit() 파일 조작에 사용하는 open(), read()가 있습니다.
그 외에도 디바이스 조작, 네트워크에 사용하는 유형도 있습니다.

#### ❓ 운영체제의 Dual Mode 에 대해 설명해 주세요.
운영 체제는 듀얼 모드에는 사용자 모드와 커널 모드가 있습니다. 사용자 모드는 일반 애플리케이션이 실행되는 모드이며
직접 하드웨어 접근이 불가능합니다. 커널 모드는 운영체제가 실행되는 모드이며 하드웨어에 직접적으로 접근이 가능합니다.
CPU에서는 이를 모드 비트(Mode Bit)로 현재 상태를 나타냅니다.
1이 사용자 모드, 2가 커널 모드입니다.

#### ❓ 왜 유저모드와 커널모드를 구분해야 하나요?
안정성과 보안성 때문입니다. 사용자가 직접 하드웨어 자원을 사용하다 문제가 생기면 시스템 전체에 문제가 생길 수 있기 때문입니다.
또한 누군가가 하드웨어를 악의적으로 접근해 악성 코드를 실행킨다면 시스템 전체에 문제가 생길 수 있습니다. 커널모드와 유저모드를 분리하면
이런 위험성을 방지할 수 있습니다.

#### ❓ 서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?
시스템 콜 번호로 구분 가능합니다. 시스템 콜을 호출하면 시스템 콜 번호가 레지스터에 저장해 이를 커널 모드에서도 
확인할 수 있습니다. 커널에서는 시스템 콜 테이블을 사용해 시스템 콜 번호에 해당하는 함수를 찾아 호출합니다. 시스템 콜 테이블에는
시스템 콜 번호와 시스템 콜에 해당하는 함수가 매핑되어 있습니다.

---

### 🔍 2. 인터럽트가 무엇인지 설명해 주세요.
인터럽트는 현재 실행 중인 작업을 잠시 멈추고, 발생한 이벤트를 우선 처리하도록 제어 흐름을 변경하는 것입니다.
CPU는 한 작업만 수행하는 구조이므로 키보드 입력과 같은 비동기적인 이벤트가 발생하면 이를 빠르게 처리하기 위해 인터럽트를 사용합니다.

#### ❓ 인터럽트는 어떻게 처리하나요?
인터럽트가 발생하면 현재 실행 중이던 프로세스의 상태를 저장합니다. 인터럽트 컨트롤러가 실행되어 인터럽트의 처리 순서를 결정하고 
인터럽트 벡터에 등록된 인터럽트 핸들러를 찾아 실행시킵니다. 일시 정지된 상태를 복원 후 다시 원래 작업으로 복귀합니다.

#### ❓ Polling 방식에 대해 설명해 주세요.
CPU가 주기적으로 이벤트가 발생했는지 확인하고 발생했다면 이를 처리하는 방식입니다. 인터럽트는 이벤트가 발생했을 때 처리하는데 Polling은 
이벤트가 발생했는지 여부를 계속 확인해야하기 때문에 polling 방식은 cpu 효율이 떨어집니다.

#### ❓ HW / SW 인터럽트에 대해 설명해 주세요.
하드웨어 인터럽트는 키보드, 마우스와 같은 외부 장치에 의해 발생하고 소프트웨어 인터럽트는 프로그램 내부에서 명령어에 의해 발생합니다.

#### ❓ 동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요?
우선순위 방식으로 처리합니다. 각 인터럽트마다 우선순위가 존재하며 우선순위가 높은 인터럽트부터 처리합니다.
인터럽트 핸들러 호출 중에도 더 높은 인터럽트가 발생하면 하던 작업을 멈추고 더 높은 순위의 인터럽트를 먼저 처리하는
방법도 같이 사용하면 시스템 응답성을 높일 수 있습니다.

---

### 🔍 3. 프로세스가 무엇인가요?
프로세스는 현재 실행중인 프로그램을 의미합니다. 프로그램이 메모리로 올라와서 cpu 자원을 할당 받은 작업 단위입니다. 운영체제에서 하나의 독립적인 작업 단위로 처리됩니다.

#### ❓ 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.
프로그램은 저장장치에 저장되어 있는 실행 가능한 파일로, 즉 정적인 상태입니다. 프로그램을 실행시키기 위해 메모리에 적재하여 실행한 것이 프로세스로 동적인 상태입니다. 컴퓨터 시스템의 작업 단위입니다.
스레드는 하나의 프로세스 내에서 실행되는 작업 단위입니다.

#### ❓ PCB가 무엇인가요?
process control block으로 프로세스 제어 블록입니다. 프로세스를 관리하기 위해 프로세스 정보가 저장되어 있습니다. 메모리 커널 영역에 생성되고 운영체체는 PCB로 프로세스를 식별하고 해당 프로세스를 처리하는데 필요한 정보를 얻습니다. PID, 레지스터 값, 프로레스 상태 등 프로세스에 대한 정보가 담겨져 있습니다.

#### ❓ 그렇다면, 스레드는 PCB를 갖고 있을까요?
스레드는 PCB대신 TCB를 갖고 있습니다. TCB는 프로그램 카운터를 포함한 레지스터의 정보, 스택 포인터, 스레드 상태 등을 갖고 있습니다.

#### ❓ 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?
프로세스는 시스템 콜인 fork()로 생성됩니다. 스레드는 pthread_create()를 사용하여 새로운 스레드를 생성합니다.

#### ❓ 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?
자식 프로세스가 상태를 알리 않고 죽으면 좀비 프로세스가 됩니다. 부모가 회수할 때 까지 커널에 남아있고 회수하지 않으면 좀비 프로세스가 계속 쌓여 자원 낭비가 발생합니다. 따라서 주기적으로 wait(), waitpid()를 호출하여 좀비 프로세스를 처리해야 합니다. 부모 프로세스가 먼저 종료되면 자식 프로세스는 고아 프로세스가 됩니다. init 프로세스의 자식으로 들어가고 init이 자식의 종료 상태를 회수해줍니다. 

#### ❓ 리눅스에서, 데몬프로세스에 대해 설명해 주세요.
백그라운드에서 사용자와 상호 작용하지 않고 정해진 일만 수행하는 프로세스입니다. 시스템 부팅시 자동 실행되고 버서, 네트워크 서비스 등과 같이 백그라운드에서 계속해서 실행되어야 하는 프로그램에서 사용됩니다.

#### ❓ 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.
루트에는 init이라고 불리는 모든 프로세스의 부모 프로세스가 존재합니다. 시스템이 부팅되면서 커널이 가장 먼저 실행하는 프로세스입니다. 고아 프로세스를 관리하고 데몬 관리, 시스템 초기화 등을 담당합니다.

---

### 🔍 4. 프로세스 주소공간에 대해 설명해 주세요.
프로세스 주소 공간은 스택, 힙, 데이터, 코드 영역으로 구분됩니다. 스택에는 지역변수, 매개변수가 저장됩니다. 힙 영역에는 동적으로 메모리가 할당되고 해제됩니다. 데이터 영역은 코드가 실행되면서 사용되는 변수, 파일등이 저장됩니다. 코드 영역에는 기계어가 저장됩니다.

#### ❓  초기화 하지 않은 변수들은 어디에 저장될까요?
초기화 하지 않은 변수는 데이터 영역 중에서도 BSS 세그먼트에 저장됩니다.  초기화된 변수는 data 세그먼트에 저장됩니다.

#### ❓ 일반적인 주소공간 그림처럼, Stack과 Heap의 크기는 매우 크다고 할 수 있을까요? 그렇지 않다면, 그 크기는 언제 결정될까요?
엄청나게 크지 않습니다. stack은 보통 MB 단위이고 heap은 동적으로 메모리를 할당받을 수는 있지만 한정된 자원이기 때문에 한계가 있습니다. stack은 컴파일 시, heap은 런타임 시 크기가 결정됩니다. 

#### ❓ Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?
stack이 빠르다고 생각합니다. stack은 단순히 포인터만 이동하면 되지만 heap은 메모리를 할당받고 해제되어야하기 때문입니다.

#### ❓ 다음과 같이 공간을 분할하는 이유가 있을까요?
한정된 자원을 더 효율적으로 사용하기 위해서입니다. 데이터를 공유하여 메모리 사용량을 줄일 수 있습니다.

#### ❓스레드의 주소공간은 어떻게 구성되어 있을까요?
스레드도 프로세스와 같이 코드, 데이터, 힙, 스택 영역으로 구성되어 있습니다. 하지만 하나의 프로세스 내에서는 스택 영역을 제외한 모든 영역을 공유합니다. 즉, 스레드는 다른 영역은 공유하면서 독립적인 스택 영역만 갖습니다. 

#### ❓ "스택"영역과 "힙"영역은 정말 자료구조의 스택/힙과 연관이 있는 걸까요? 만약 그렇다면, 각 주소공간의 동작과정과 연계해서 설명해 주세요.
스택은 자료구조 스택과 유사하게 동작합니다. 먼저 호출된 함수의 스택 역이 나중에 호출된 스택 영역보다 나중에 해제되는 후입선출을 따릅니다. 힙 영역은 연관이 없습니다. 자료구조의 힙은 자료의 우선순위에 따라 정렬되는 반면, 메모리의 힙 영역은 동적으로 메모리를 할당하고 해제하는 역할을 하기에 연관이 없습니다.

#### ❓ IPC의 Shared Memory 기법은 프로세스 주소공간의 어디에 들어가나요? 그런 이유가 있을까요?
힙 영역에 할당되어 메모리 주소를 직접 공유하는 방식으로 데이터를 교환할 수 있게 해줍니다. 공유 메모리에 직접 읽고 쓰기 때문에 데이터 전달이 필요없어 더 빠른 데이터 공유가 가능합니다.

#### ❓ 스택과 힙영역의 크기는 언제 결정되나요? 프로그램 개발자가 아닌, 사용자가 이 공간의 크기를 수정할 수 있나요?
스택은 컴파일 시, 힙은 런타임에 크기가 결정됩니다. 프로그램 실행 시 운영 체제에 의해 할당됩니다. 사용자가 직접 크기를 수정하는 것은 권장되지 않습니다.

---
### 🔍 6. 컨텍스트 스위칭 시에는 어떤 일들이 일어나나요?
먼저 컨텍스트 스위칭은 프로세스 간에 실행을 전환하는 것을 의미합니다. 기존 프로세스 문맥을 PCB에 백업하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행합니다. 실제로 컴퓨터는 하나의 프로세스만 실행할 수 있으며 프로세스가 빨리 번갈아 실행되기 때문에 동시에 실행되는 것처럼 보입니다.

#### ❓ 프로세스와 스레드는 컨텍스트 스위칭이 발생했을 때 어떤 차이가 있을까요?
스레드에서 일어나는 컨텍스트 스위칭이 프로세스에서 발생하는 것보다 훨씬 빠릅니다. TCB가 PCB보다 가볍고 간단한 정보만 저장하기 때문에 읽고 쓸 때 빠릅니다. 또한 캐시 메모리를 초기화할 필요가 없습니다.

#### ❓ 컨텍스트 스위칭이 발생할 때, 기존의 프로세스 정보는 커널스택에 어떠한 형식으로 저장되나요?
PCB에 PC, register, 메모리 관리 정보, 스택 및 힙 포인터 등의 정보를 포함하여 저장합니다.

#### ❓ 컨텍스트 스위칭은 언제 일어날까요?
크케 타임아웃과 인터럽트 2가지 경우가 있습니다 타임아웃은 한 프로세스가 자신에게 주어진 시간을 다 사용하면 발생합니다. 인터럽트는 한 프로세스가 자신에게 주어진 메모리 공간을 넘어가려 할 때 발생합니다.
