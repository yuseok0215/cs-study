### 🔍 1. 시스템 콜이 무엇인지 설명해 주세요.
시스템 콜은 응용 프로그램이 운영 체제의 커널 기능을 사용할 수 있도록 제공하는 인터페이스입니다. 
운영 체제는 하드웨어의 자원을 직접 접근할 수 있지만 일반 프로그램은 직접 접근이 불가능하기 때문에 시스템 콜이 필요합니다.
시스템 콜을 통해 커널 모드로 전환해 하드웨어 자원을 사용할 수 있게 됩니다.

#### ❓ 우리가 사용하는 시스템 콜의 예시를 들어주세요.
파일을 열 때 사용하는 open(), 파일을 읽고 쓸 때 read(), write()가 있습니다. 프로세스를 실행시킬 때의 fork(), 
소켓 생성을 위한 socket()도 있습니다.

#### ❓ 시스템 콜이, 운영체제에서 어떤 과정으로 실행되는지 설명해 주세요.
시스템 콜을 호출하면 시스템 콜 번호와 필요한 매개변수를 레지스터에 저장되고 CPU에 인터럽트가 발생해
사용자 모드에서 커널 모드로 전환됩니다. 커널이 레지스터에 저장된 시스템 콜 번호를 읽어 시스템 콜 테이블에서
해당 함수를 찾은 뒤 함수를 실행합니다. 작업이 끝나면 결과 값을 레지스터에 저장하고 커널 모드에서 사용자 모드로 돌아갑니다.

#### ❓시스템 콜의 유형에 대해 설명해 주세요.
프로세스 제어를 위한 fork(), exit() 파일 조작에 사용하는 open(), read()가 있습니다.
그 외에도 디바이스 조작, 네트워크에 사용하는 유형도 있습니다.

#### ❓ 운영체제의 Dual Mode 에 대해 설명해 주세요.
운영 체제는 듀얼 모드에는 사용자 모드와 커널 모드가 있습니다. 사용자 모드는 일반 애플리케이션이 실행되는 모드이며
직접 하드웨어 접근이 불가능합니다. 커널 모드는 운영체제가 실행되는 모드이며 하드웨어에 직접적으로 접근이 가능합니다.
CPU에서는 이를 모드 비트(Mode Bit)로 현재 상태를 나타냅니다.
1이 사용자 모드, 2가 커널 모드입니다.

#### ❓ 왜 유저모드와 커널모드를 구분해야 하나요?
안정성과 보안성 때문입니다. 사용자가 직접 하드웨어 자원을 사용하다 문제가 생기면 시스템 전체에 문제가 생길 수 있기 때문입니다.
또한 누군가가 하드웨어를 악의적으로 접근해 악성 코드를 실행킨다면 시스템 전체에 문제가 생길 수 있습니다. 커널모드와 유저모드를 분리하면
이런 위험성을 방지할 수 있습니다.

#### ❓ 서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?
시스템 콜 번호로 구분 가능합니다. 시스템 콜을 호출하면 시스템 콜 번호가 레지스터에 저장해 이를 커널 모드에서도 
확인할 수 있습니다. 커널에서는 시스템 콜 테이블을 사용해 시스템 콜 번호에 해당하는 함수를 찾아 호출합니다. 시스템 콜 테이블에는
시스템 콜 번호와 시스템 콜에 해당하는 함수가 매핑되어 있습니다.

---

### 🔍 2. 인터럽트가 무엇인지 설명해 주세요.
인터럽트는 현재 실행 중인 작업을 잠시 멈추고, 발생한 이벤트를 우선 처리하도록 제어 흐름을 변경하는 것입니다.
CPU는 한 작업만 수행하는 구조이므로 키보드 입력과 같은 비동기적인 이벤트가 발생하면 이를 빠르게 처리하기 위해 인터럽트를 사용합니다.

#### ❓ 인터럽트는 어떻게 처리하나요?
인터럽트가 발생하면 현재 실행 중이던 프로세스의 상태를 저장합니다. 인터럽트 컨트롤러가 실행되어 인터럽트의 처리 순서를 결정하고 
인터럽트 벡터에 등록된 인터럽트 핸들러를 찾아 실행시킵니다. 일시 정지된 상태를 복원 후 다시 원래 작업으로 복귀합니다.

#### ❓ Polling 방식에 대해 설명해 주세요.
CPU가 주기적으로 이벤트가 발생했는지 확인하고 발생했다면 이를 처리하는 방식입니다. 인터럽트는 이벤트가 발생했을 때 처리하는데 Polling은 
이벤트가 발생했는지 여부를 계속 확인해야하기 때문에 polling 방식은 cpu 효율이 떨어집니다.

#### ❓ HW / SW 인터럽트에 대해 설명해 주세요.
하드웨어 인터럽트는 키보드, 마우스와 같은 외부 장치에 의해 발생하고 소프트웨어 인터럽트는 프로그램 내부에서 명령어에 의해 발생합니다.

#### ❓ 동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요?
우선순위 방식으로 처리합니다. 각 인터럽트마다 우선순위가 존재하며 우선순위가 높은 인터럽트부터 처리합니다.
인터럽트 핸들러 호출 중에도 더 높은 인터럽트가 발생하면 하던 작업을 멈추고 더 높은 순위의 인터럽트를 먼저 처리하는
방법도 같이 사용하면 시스템 응답성을 높일 수 있습니다.

---

### 🔍 3. 프로세스가 무엇인가요?
#### ❓ 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.
#### ❓ PCB가 무엇인가요?
#### ❓ 그렇다면, 스레드는 PCB를 갖고 있을까요?
#### ❓ 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?
#### ❓ 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?
#### ❓ 리눅스에서, 데몬프로세스에 대해 설명해 주세요.
#### ❓ 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.
