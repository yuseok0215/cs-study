### 🔍 1. 시스템 콜이 무엇인지 설명해 주세요.
시스템 콜은 응용 프로그램이 운영 체제의 커널 기능을 사용할 수 있도록 제공하는 인터페이스입니다. 
운영 체제는 하드웨어의 자원을 직접 접근할 수 있지만 일반 프로그램은 직접 접근이 불가능하기 때문에 시스템 콜이 필요합니다.
시스템 콜을 통해 커널 모드로 전환해 하드웨어 자원을 사용할 수 있게 됩니다.

#### ❓ 우리가 사용하는 시스템 콜의 예시를 들어주세요.
파일을 열 때 사용하는 open(), 파일을 읽고 쓸 때 read(), write()가 있습니다. 프로세스를 실행시킬 때의 fork(), 
소켓 생성을 위한 socket()도 있습니다.

#### ❓ 시스템 콜이, 운영체제에서 어떤 과정으로 실행되는지 설명해 주세요.
시스템 콜을 호출하면 시스템 콜 번호와 필요한 매개변수를 레지스터에 저장되고 CPU에 인터럽트가 발생해
사용자 모드에서 커널 모드로 전환됩니다. 커널이 레지스터에 저장된 시스템 콜 번호를 읽어 시스템 콜 테이블에서
해당 함수를 찾은 뒤 함수를 실행합니다. 작업이 끝나면 결과 값을 레지스터에 저장하고 커널 모드에서 사용자 모드로 돌아갑니다.

#### ❓시스템 콜의 유형에 대해 설명해 주세요.
프로세스 제어를 위한 fork(), exit() 파일 조작에 사용하는 open(), read()가 있습니다.
그 외에도 디바이스 조작, 네트워크에 사용하는 유형도 있습니다.

#### ❓ 운영체제의 Dual Mode 에 대해 설명해 주세요.
운영 체제는 듀얼 모드에는 사용자 모드와 커널 모드가 있습니다. 사용자 모드는 일반 애플리케이션이 실행되는 모드이며
직접 하드웨어 접근이 불가능합니다. 커널 모드는 운영체제가 실행되는 모드이며 하드웨어에 직접적으로 접근이 가능합니다.
CPU에서는 이를 모드 비트(Mode Bit)로 현재 상태를 나타냅니다.
1이 사용자 모드, 2가 커널 모드입니다.

#### ❓ 왜 유저모드와 커널모드를 구분해야 하나요?
안정성과 보안성 때문입니다. 사용자가 직접 하드웨어 자원을 사용하다 문제가 생기면 시스템 전체에 문제가 생길 수 있기 때문입니다.
또한 누군가가 하드웨어를 악의적으로 접근해 악성 코드를 실행킨다면 시스템 전체에 문제가 생길 수 있습니다. 커널모드와 유저모드를 분리하면
이런 위험성을 방지할 수 있습니다.

#### ❓ 서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?
시스템 콜 번호로 구분 가능합니다. 시스템 콜을 호출하면 시스템 콜 번호가 레지스터에 저장해 이를 커널 모드에서도 
확인할 수 있습니다. 커널에서는 시스템 콜 테이블을 사용해 시스템 콜 번호에 해당하는 함수를 찾아 호출합니다. 시스템 콜 테이블에는
시스템 콜 번호와 시스템 콜에 해당하는 함수가 매핑되어 있습니다.

---

### 🔍 2. 인터럽트가 무엇인지 설명해 주세요.
인터럽트는 현재 실행 중인 작업을 잠시 멈추고, 발생한 이벤트를 우선 처리하도록 제어 흐름을 변경하는 것입니다.
CPU는 한 작업만 수행하는 구조이므로 키보드 입력과 같은 비동기적인 이벤트가 발생하면 이를 빠르게 처리하기 위해 인터럽트를 사용합니다.

#### ❓ 인터럽트는 어떻게 처리하나요?
인터럽트가 발생하면 현재 실행 중이던 프로세스의 상태를 저장합니다. 인터럽트 컨트롤러가 실행되어 인터럽트의 처리 순서를 결정하고 
인터럽트 벡터에 등록된 인터럽트 핸들러를 찾아 실행시킵니다. 일시 정지된 상태를 복원 후 다시 원래 작업으로 복귀합니다.

#### ❓ Polling 방식에 대해 설명해 주세요.
CPU가 주기적으로 이벤트가 발생했는지 확인하고 발생했다면 이를 처리하는 방식입니다. 인터럽트는 이벤트가 발생했을 때 처리하는데 Polling은 
이벤트가 발생했는지 여부를 계속 확인해야하기 때문에 polling 방식은 cpu 효율이 떨어집니다.

#### ❓ HW / SW 인터럽트에 대해 설명해 주세요.
하드웨어 인터럽트는 키보드, 마우스와 같은 외부 장치에 의해 발생하고 소프트웨어 인터럽트는 프로그램 내부에서 명령어에 의해 발생합니다.

#### ❓ 동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요?
우선순위 방식으로 처리합니다. 각 인터럽트마다 우선순위가 존재하며 우선순위가 높은 인터럽트부터 처리합니다.
인터럽트 핸들러 호출 중에도 더 높은 인터럽트가 발생하면 하던 작업을 멈추고 더 높은 순위의 인터럽트를 먼저 처리하는
방법도 같이 사용하면 시스템 응답성을 높일 수 있습니다.

---

### 🔍 3. 프로세스가 무엇인가요?
프로세스는 현재 실행중인 프로그램을 의미합니다. 프로그램이 메모리로 올라와서 cpu 자원을 할당 받은 작업 단위입니다. 운영체제에서 하나의 독립적인 작업 단위로 처리됩니다.

#### ❓ 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.
프로그램은 저장장치에 저장되어 있는 실행 가능한 파일로, 즉 정적인 상태입니다. 프로그램을 실행시키기 위해 메모리에 적재하여 실행한 것이 프로세스로 동적인 상태입니다. 컴퓨터 시스템의 작업 단위입니다.
스레드는 하나의 프로세스 내에서 실행되는 작업 단위입니다.

#### ❓ PCB가 무엇인가요?
process control block으로 프로세스 제어 블록입니다. 프로세스를 관리하기 위해 프로세스 정보가 저장되어 있습니다. 메모리 커널 영역에 생성되고 운영체체는 PCB로 프로세스를 식별하고 해당 프로세스를 처리하는데 필요한 정보를 얻습니다. PID, 레지스터 값, 프로레스 상태 등 프로세스에 대한 정보가 담겨져 있습니다.

#### ❓ 그렇다면, 스레드는 PCB를 갖고 있을까요?
스레드는 PCB대신 TCB를 갖고 있습니다. TCB는 프로그램 카운터를 포함한 레지스터의 정보, 스택 포인터, 스레드 상태 등을 갖고 있습니다.

#### ❓ 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?
프로세스는 시스템 콜인 fork()로 생성됩니다. 스레드는 pthread_create()를 사용하여 새로운 스레드를 생성합니다.

#### ❓ 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?
자식 프로세스가 상태를 알리 않고 죽으면 좀비 프로세스가 됩니다. 부모가 회수할 때 까지 커널에 남아있고 회수하지 않으면 좀비 프로세스가 계속 쌓여 자원 낭비가 발생합니다. 따라서 주기적으로 wait(), waitpid()를 호출하여 좀비 프로세스를 처리해야 합니다. 부모 프로세스가 먼저 종료되면 자식 프로세스는 고아 프로세스가 됩니다. init 프로세스의 자식으로 들어가고 init이 자식의 종료 상태를 회수해줍니다. 

#### ❓ 리눅스에서, 데몬프로세스에 대해 설명해 주세요.
백그라운드에서 사용자와 상호 작용하지 않고 정해진 일만 수행하는 프로세스입니다. 시스템 부팅시 자동 실행되고 버서, 네트워크 서비스 등과 같이 백그라운드에서 계속해서 실행되어야 하는 프로그램에서 사용됩니다.

#### ❓ 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.
루트에는 init이라고 불리는 모든 프로세스의 부모 프로세스가 존재합니다. 시스템이 부팅되면서 커널이 가장 먼저 실행하는 프로세스입니다. 고아 프로세스를 관리하고 데몬 관리, 시스템 초기화 등을 담당합니다.

---

### 🔍 4. 프로세스 주소공간에 대해 설명해 주세요.
프로세스 주소 공간은 스택, 힙, 데이터, 코드 영역으로 구분됩니다. 스택에는 지역변수, 매개변수가 저장됩니다. 힙 영역에는 동적으로 메모리가 할당되고 해제됩니다. 데이터 영역은 코드가 실행되면서 사용되는 변수, 파일등이 저장됩니다. 코드 영역에는 기계어가 저장됩니다.

#### ❓  초기화 하지 않은 변수들은 어디에 저장될까요?
초기화 하지 않은 변수는 데이터 영역 중에서도 BSS 세그먼트에 저장됩니다.  초기화된 변수는 data 세그먼트에 저장됩니다.

#### ❓ 일반적인 주소공간 그림처럼, Stack과 Heap의 크기는 매우 크다고 할 수 있을까요? 그렇지 않다면, 그 크기는 언제 결정될까요?
엄청나게 크지 않습니다. stack은 보통 MB 단위이고 heap은 동적으로 메모리를 할당받을 수는 있지만 한정된 자원이기 때문에 한계가 있습니다. stack은 컴파일 시, heap은 런타임 시 크기가 결정됩니다. 

#### ❓ Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?
stack이 빠르다고 생각합니다. stack은 단순히 포인터만 이동하면 되지만 heap은 메모리를 할당받고 해제되어야하기 때문입니다.

#### ❓ 다음과 같이 공간을 분할하는 이유가 있을까요?
한정된 자원을 더 효율적으로 사용하기 위해서입니다. 데이터를 공유하여 메모리 사용량을 줄일 수 있습니다.

#### ❓스레드의 주소공간은 어떻게 구성되어 있을까요?
스레드도 프로세스와 같이 코드, 데이터, 힙, 스택 영역으로 구성되어 있습니다. 하지만 하나의 프로세스 내에서는 스택 영역을 제외한 모든 영역을 공유합니다. 즉, 스레드는 다른 영역은 공유하면서 독립적인 스택 영역만 갖습니다. 

#### ❓ "스택"영역과 "힙"영역은 정말 자료구조의 스택/힙과 연관이 있는 걸까요? 만약 그렇다면, 각 주소공간의 동작과정과 연계해서 설명해 주세요.
스택은 자료구조 스택과 유사하게 동작합니다. 먼저 호출된 함수의 스택 역이 나중에 호출된 스택 영역보다 나중에 해제되는 후입선출을 따릅니다. 힙 영역은 연관이 없습니다. 자료구조의 힙은 자료의 우선순위에 따라 정렬되는 반면, 메모리의 힙 영역은 동적으로 메모리를 할당하고 해제하는 역할을 하기에 연관이 없습니다.

#### ❓ IPC의 Shared Memory 기법은 프로세스 주소공간의 어디에 들어가나요? 그런 이유가 있을까요?
힙 영역에 할당되어 메모리 주소를 직접 공유하는 방식으로 데이터를 교환할 수 있게 해줍니다. 공유 메모리에 직접 읽고 쓰기 때문에 데이터 전달이 필요없어 더 빠른 데이터 공유가 가능합니다.

#### ❓ 스택과 힙영역의 크기는 언제 결정되나요? 프로그램 개발자가 아닌, 사용자가 이 공간의 크기를 수정할 수 있나요?
스택은 컴파일 시, 힙은 런타임에 크기가 결정됩니다. 프로그램 실행 시 운영 체제에 의해 할당됩니다. 사용자가 직접 크기를 수정하는 것은 권장되지 않습니다.

---
### 🔍 5. 단기, 중기, 장기 스케쥴러에 대해 설명해 주세요
장기 스케줄링은 시스템 내의 전체 작업 수를 조절합니다. 어떤 작업을 시스템이 받아들일지 거부할지를 결정하며 동시에 실행 가능한 프로세스의 총 개수가 정해집니다.
중기 스케줄링은 메모리가 부족할 때 일시적으로 프로세스를 메모리에서 제거합니다. 시스템에 과부하가 걸려 전체 프로세스 수를 조절해야 한다면 이미 활성화된 프로세스 중 일부를 중지 상태로 변경합니다.
단기 스케줄링은 어떤 프로세스에 cpu를 할당할지 결정합니다. 

#### ❓ 현대 OS에는 단기, 중기, 장기 스케쥴러를 모두 사용하고 있나요?
현대 운영체제는 대부분 장기 스케줄러 없이 단기와 중기 스케줄러만 사용합니다.
장기 스케줄러는 작업을 제한하는 용도로 사용되었지만, 현대 시스템은 사용자 요청 기반이기 때문에 불필요해졌습니다.

#### ❓ 프로세스의 스케쥴링 상태에 대해 설명해 주세요.
프로세스는 New, Ready, Running, Waiting, Terminated 등의 상태를 거칩니다.
CPU를 기다릴 땐 Ready, 실행 중에는 Running, I/O 등 외부 이벤트를 기다리면 Waiting 상태로 전환됩니다.

#### ❓ preemptive/non-preemptive 에서 존재할 수 없는 상태가 있을까요?
Preemptive과 Non-preemptive 스케줄링 모두 동일한 프로세스 상태를 갖지만, 상태 전이가 운영체제 개입 여부에 따라 다릅니다.
예를 들어 Preemptive에서는 CPU 시간을 초과하면 강제로 Ready로 돌아가지만, Non-preemptive에서는 프로세스가 자발적으로 양보해야 상태가 전이됩니다.

#### ❓ Memory가 부족할 경우, Process는 어떠한 상태로 변화할까요?
메모리가 부족한 경우, 중기 스케줄러가 개입해 일부 프로세스를 메모리에서 내리고 Suspended 상태로 전환시킵니다.
이후 메모리가 여유로워지면 다시 Ready 상태로 복귀시켜 실행 대기열에 넣습니다.

---
### 🔍 6. 컨텍스트 스위칭 시에는 어떤 일들이 일어나나요?
먼저 컨텍스트 스위칭은 프로세스 간에 실행을 전환하는 것을 의미합니다. 기존 프로세스 문맥을 PCB에 백업하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행합니다. 실제로 컴퓨터는 하나의 프로세스만 실행할 수 있으며 프로세스가 빨리 번갈아 실행되기 때문에 동시에 실행되는 것처럼 보입니다.

#### ❓ 프로세스와 스레드는 컨텍스트 스위칭이 발생했을 때 어떤 차이가 있을까요?
스레드에서 일어나는 컨텍스트 스위칭이 프로세스에서 발생하는 것보다 훨씬 빠릅니다. TCB가 PCB보다 가볍고 간단한 정보만 저장하기 때문에 읽고 쓸 때 빠릅니다. 또한 캐시 메모리를 초기화할 필요가 없습니다.

#### ❓ 컨텍스트 스위칭이 발생할 때, 기존의 프로세스 정보는 커널스택에 어떠한 형식으로 저장되나요?
PCB에 PC, register, 메모리 관리 정보, 스택 및 힙 포인터 등의 정보를 포함하여 저장합니다.

#### ❓ 컨텍스트 스위칭은 언제 일어날까요?
크케 타임아웃과 인터럽트 2가지 경우가 있습니다 타임아웃은 한 프로세스가 자신에게 주어진 시간을 다 사용하면 발생합니다. 인터럽트는 한 프로세스가 자신에게 주어진 메모리 공간을 넘어가려 할 때 발생합니다.

---
### 🔍 7. 프로세스 스케줄링 알고리즘에는 어떤 것들이 있나요?
프로세스 스케줄링 알고리즘에는 FCFS, SJF, Round Robin, Priority, MLFQ 등이 있습니다.
FCFS(First-Come-First-Serve)은 도착 순서대로 처리합니다.
SJF(Shortest Job First)은 실행 시간이 짧은 순서대로 처리합니다.
RR(Round Robin)은 고정 시간만큼 할당 후 교체합니다.
Priority Scheduling은 우선순위가 높은 프로세스 우선 실행힙니다.
MLFQ(Multi-Level Feedback Queue)은 다양한 우선순위 큐로 구성하며 동적으로 조정합니다.

#### ❓ RR을 사용할 때, Time Slice에 따른 trade-off를 설명해 주세요.
Time Slice가 짧을수록 응답성은 좋아지지만, Context Switching 오버헤드가 커집니다.
Round Robin은 각 프로세스에 일정 시간만큼 CPU를 분배하는 방식으로, 공정성과 응답성을 높이는 데 효과적입니다.
예를 들어 Time Slice를 50ms로 설정하면 빠르게 응답하지만 프로세스 전환이 너무 자주 발생해 CPU 리소스 낭비가 심해질 수 있습니다. 반면 1000ms로 설정하면 전환 횟수는 줄지만, 사용자 입장에서는 대기 시간이 길어집니다.
따라서 Time Slice는 시스템 특성과 사용자 요구를 고려해 적절히 설정해야 하며, 실시간 시스템에서는 더 정밀한 제어가 필요합니다.

#### ❓ 싱글 스레드 CPU에서 상시로 돌아가야 하는 프로세스가 있다면, 어떤 스케줄링 알고리즘이 적합할까요?
상시 실행이 필요한 프로세스가 있다면 우선순위 기반 스케줄링(Priority Scheduling)이 적합합니다.
이 알고리즘은 중요도에 따라 프로세스의 실행 순서를 결정하므로, 항상 동작해야 하는 프로세스에 높은 우선순위를 부여함으로써 먼저 실행할 수 있습니다.
예를 들어, 시스템 로그를 기록하는 데몬은 항상 백그라운드에서 실행되어야 하므로 높은 우선순위를 주어야 합니다.
단점으로는 낮은 우선순위를 가진 프로세스가 무한정 대기할 수 있는 starvation 문제가 있으며, 이를 방지하기 위해 Aging 기법 등을 같이 적용합니다.

#### ❓ 동시성과 병렬성의 차이에 대해 설명해 주세요.
동시성은 싱글 코어 환경에서도 스케줄링을 통해 여러 작업이 동시에 처리되는 것처럼 보이게 하는 방식이며, 병렬성은 멀티코어 환경에서 실제로 여러 작업이 동시에 실행되는 것을 의미합니다. 예를 들어, 하나의 CPU가 A → B → A → B 순으로 번갈아 처리하면 동시성이고, 두 CPU가 A, B를 동시에 처리하면 병렬성입니다.

#### ❓ MLFQ는 어떤 문제를 해결할 수 있을까요?
MLFQ는 SJF의 실행 시간 예측 한계와 Priority Scheduling의 starvation 문제를 동시에 해결할 수 있습니다.
MLFQ는 여러 개의 우선순위 큐를 사용하고, 프로세스의 행동에 따라 큐를 이동시키며 동적으로 우선순위를 조정합니다.
이 방식은 다양한 유형의 프로세스를 공정하고 효율적으로 처리할 수 있지만, 큐 설계와 정책 결정이 복잡하다는 단점이 있습니다.

#### ❓ FIFO 스케줄러는 정말 쓸모가 없는가요?
FIFO는 도착 순서대로 프로세스를 처리하는 가장 기본적인 방식으로, 시스템 오버헤드가 적고 공정성이 보장됩니다.
예를 들어, 일괄적으로 데이터를 처리하는 배치 작업이나 로그 분석과 같이 순서가 중요한 작업에는 효과적입니다.
하지만 짧은 작업이 긴 작업 뒤에 대기하는 문제 발생할 수 있기 때문에, 실시간 시스템이나 사용자 인터페이스 처리에는 적합하지 않습니다.

#### ❓ 우리는 스케줄링 알고리즘을 "프로세스" 스케줄링 알고리즘이라고 부릅니다. 스레드는 다른 방식으로 스케줄링을 하나요?
스레드는 커널 입장에서는 프로세스와 동일하게 취급되어, 동일한 방식으로 스케줄링됩니다.
커널은 커널 스레드를 실행 단위로 보고, 라운드 로빈, 우선순위 기반 등 일반적인 프로세스 스케줄링 알고리즘을 그대로 적용합니다.
스레드는 주소 공간을 공유하므로, 컨텍스트 스위칭 비용이 낮다는 장점이 있지만, 너무 많은 스레드 생성은 오히려 성능 저하를 유발할 수 있습니다.

#### ❓ 유저 스레드와 커널 스레드의 스케쥴링 알고리즘은 똑같을까요?
유저 스레드와 커널 스레드는 스케줄링 방식이 다릅니다.
커널 스레드는 OS가 직접 관리하며, 프로세스와 동일한 스케줄링 알고리즘이 적용됩니다. 반면 유저 스레드는 운영체제가 인식하지 못해, 사용자 라이브러리 수준에서 독립적으로 스케줄링됩니다. 또한 커널 스레드는 병렬 처리가 가능하지만 유저 스레드는 병렬 처리도 불가능합니다.
