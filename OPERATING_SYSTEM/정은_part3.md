### 16. Thrashing이란 무엇인가요?

- **정의**
    
    여러 프로세스가 동시에 메모리 확보를 위해 페이지 교체를 과도하게 일으켜, 실제 연산보다 페이지 교체 비용이 더 커지는 현상입니다.
    
- **완화 방법**
    1. **워킹 세트 모델**을 이용해 프로세스별 최소·최적 페이지 집합을 유지
    2. **멀티프로그래밍 정도 조절**: 동시에 메모리에 올라올 프로세스 수 제한
    3. **페이지 폴트 빈도 제어**(페이지 폴트율 임계값 조정)
    4. **메모리 할당 정책 변경**: 지역성 기반 할당, 우선순위 기반 스케줄링

---

### 17. 가상 메모리(Virtual Memory)란 무엇인가요?

- **정의**
    
    프로세스마다 독립된 0부터 시작하는 연속적인 주소 공간을 제공하고, 실제 물리 메모리는 페이지 단위로 매핑하여 사용하게 하는 기법입니다.
    
- **가상 메모리가 가능한 이유**
    1. **페이지 테이블**을 통한 동적 주소 변환
    2. *디스크를 백스토어(backing store)**로 활용하여, 필요한 페이지만 메모리에 로드
- **Page Fault 처리 과정**
    1. CPU가 접근한 페이지가 메모리에 없으면 트랩(trap) 발생
    2. 커널이 디스크에서 해당 페이지를 읽어와 물리 메모리에 적재
    3. 페이지 테이블 갱신 → 프로세스 재실행
- **페이지 크기(Page Size) Trade-Off**
    - **크게** 하면
        - 페이지 테이블 엔트리 수 감소 → 관리 오버헤드 ↓
        - 내부 단편화(internal fragmentation) ↑
    - **작게** 하면
        - 외부 단편화(external fragmentation) ↓
        - 페이지 폴트 발생 시 I/O 오버헤드 ↑
- **페이지 크기가 커지면 페이지 폴트가 더 많이 발생하나요?**
    - 일반적으로 한 번 로드 시 더 많은 데이터를 가져와 지역성 활용도가 높아질 수 있지만, 지나치게 크면 내부 단편화로 메모리 낭비가 커지고, 캐시·TLB 효율이 떨어져 오히려 페이지 폴트가 증가할 수도 있습니다.
- **세그멘테이션 방식에서도 가상 메모리를 사용할 수 있나요?**
    - 예. 세그먼트 단위로 디스크에서 로드하거나, 세그먼트→페이지 혼합 방식으로 구현할 수 있습니다.

---

### 18. 세그멘테이션(Segmentation)과 페이징(Paging)의 차이점

| 구분 | 세그멘테이션 | 페이징 |
| --- | --- | --- |
| 단위 | 논리적 단위(코드, 데이터, 스택 등 가변 크기) | 고정 크기 페이지 (예: 4KB) |
| 단편화 | 외부 단편화 발생 가능 | 내부 단편화 발생 |
| 주소 변환 | 세그먼트번호 + 오프셋 → 세그먼트 테이블 조회 | 페이지번호 + 오프셋 → 페이지 테이블 조회 |
| 구현 복잡도 | 상대적으로 복잡 (다양한 크기 관리) | 단순 (고정 크기로 균일 관리) |
- **페이지와 프레임(Frame)의 차이**
    - 가상 주소 공간 쪽의 페이지(page)와 물리 메모리 쪽의 프레임(frame)은 크기가 동일한 블록 단위입니다.
- **단편화**
    - **내부 단편화**: 페이징에서, 마지막 페이지에 사용되지 않는 공간
    - **외부 단편화**: 세그멘테이션에서, 가용 메모리가 여러 조각으로 분산
- **실제 물리 주소 계산**
    
    ```
    복사편집
    물리주소 = (프레임번호 × 페이지크기) + 오프셋
    
    ```
    
- **접근 권한 확인**
    
    페이지 테이블 엔트리의 **프로텍션 비트**(read/write/execute 등)로 검사
    
- **32비트 + 페이지 크기 1KB일 때 페이지 테이블 엔트리 개수**
    
    ```
    복사편집
    2^32 전체 주소공간 / 2^10 페이지 크기 = 2^22 ≈ 4백만 개
    
    ```
    
- **32비트 OS가 RAM 최대 4GB를 사용하는 이유**
    
    32비트 주소 공간 = 2^32 = 4,294,967,296 bytes = 4GB
    
- **Segmentation Fault와의 관계**
    - 잘못된 세그먼트 접근(유효하지 않거나 권한 없는 세그먼트)에 대한 CPU 예외

---

### 19. TLB(Translation Lookaside Buffer)란 무엇인가요?

- **정의**
    
    페이지 테이블의 최근 참조 엔트리를 캐시하는 고속 메모리입니다.
    
- **TLB 사용 시 속도가 빨라지는 이유**
    
    매번 메모리에서 페이지 테이블을 조회하지 않고, TLB 히트 시 즉시 물리 주소 변환 가능
    
- **MMU(Memory Management Unit)란?**
    
    CPU 내부의 주소 변환·메모리 보호 기능을 담당하는 하드웨어 모듈
    
- **위치**
    
    CPU 칩셋 내부, MMU 안에 TLB가 통합된 형태
    
- **멀티코어에서 TLB 동기화**
    - 각 코어별로 별도 TLB 유지
    - 주소 공간 전환 시 **TLB Shootdown**(IPI(inter-processor interrupt)로 다른 코어 TLB 플러시)
- **Context Switch 시 변화**
    - 프로세스별 페이지 테이블이 달라지므로 **TLB 플러시** 또는 프로세스 식별자(ASID) 변경

---

### 20. 동기화 구현을 위한 하드웨어적 해결 방법

- **Atomic Instruction**
    - Test-and-Set, Compare-and-Swap(CAS), Fetch-and-Add 등
- **volatile 키워드 의미**
    - 컴파일러 최적화로 인한 레지스터 캐싱을 방지
    - 메모리에서 직접 읽고 쓰도록 힌트 제공
- **멀티코어 동기화**
    - **캐시 일관성 프로토콜**(MESI, MOESI 등)
    - 하드웨어가 캐시 라인 단위로 동기화

---

### 21. 페이지 교체 알고리즘

- **LRU(Least Recently Used)**
    - **특성**: 과거에 가장 오래 사용되지 않은 페이지 교체 (시간 지역성 가정)
    - **구현 방법**:
        1. **스택 알고리즘**(정확 but 비용 큼)
        2. **참조 비트** + **클록(Second-Chance) 알고리즘**(근사 LRU)
    - **단점**:
        - 완전 구현 시 오버헤드 큼
        - HW 트래킹 필요 → 복잡
    - **대안**: CLOCK, NFU(가중치 누적), LFU, Random 등

---

### 22. File Descriptor와 File System

- **File Descriptor(FD)**
    - 프로세스별 **정수 핸들**
    - 커널 내부의 오픈 파일 테이블 인덱스로 매핑
- **I-Node**
    - 파일 메타데이터(권한, 소유자, 크기, 데이터 블록 포인터 등) 저장
- **프로그래밍 언어 상 파일 함수 처리**
    - `open()` → 커널의 `open(2)` 시스템 콜 → FD 반환
    - `read()`/`write()` → 커널 버퍼(Cache)로부터 데이터 입출력
    - Java `BufferedReader/Writer` 등은 **사용자 공간 버퍼**를 두어 시스템 콜 횟수를 줄임

---

### 23. 동기(Sync) vs 비동기(Async), 블로킹(Blocking) vs 논블로킹(Non-blocking)

- **동기 vs 비동기**
    - **동기**: 호출한 쪽이 작업 완료를 기다림
    - **비동기**: 호출 후 즉시 반환, 결과를 콜백·이벤트·퓨처 등으로 처리
- **블로킹 vs 논블로킹**
    - **블로킹**: 호출 시 완료 전까지 스레드가 대기
    - **논블로킹**: 호출 즉시 반환, 완료 여부는 별도 확인 기법으로
- **조합 가능성**
    
    
    |  | 블로킹 | 논블로킹 |
    | --- | --- | --- |
    | **동기** | 일반적인 `read()`/`write()` | 즉시 결과 반환하는 폴링 API (rare) |
    | **비동기** | 일부 프레임워크의 Future.get()처럼 결과 수신 시까지 블록 | 표준적인 비동기 처리 모델 (콜백, 이벤트) |
- **I/O 멀티플렉싱**
    - `select()`, `poll()`, `epoll()` 등으로 여러 FD를 한 번에 감시
- **논블로킹 I/O 결과 수신 방법**
    - **폴링(polling)**: 주기적 상태 확인
    - **이벤트 드리븐**: 콜백, 이벤트 큐
    - **Completion Port** (Windows), **AIO** 인터페이스
