## **8.1 뮤텍스와 세마포어의 차이점은 무엇인가요?**

두 개념 모두 공유 자원에 대한 접근을 제어하는 동기화 도구입니다.
하지만 동작 방식과 사용 목적에서 몇 가지 차이점이 있습니다.

먼저, **뮤텍스(Mutex)**는 이름 그대로 Mutual Exclusion, 즉 상호배제를 위한 도구입니다.

뮤텍스는 한 번에 하나의 스레드만 공유 자원에 접근할 수 있도록 합니다.
특정 스레드가 뮤텍스를 획득(lock)하면, 다른 스레드는 해당 뮤텍스를 사용할 수 없고 대기 상태가 됩니다.
그리고 뮤텍스를 획득한 스레드만 해제(unlock)할 수 있습니다.
즉, 소유권 개념이 존재합니다.

반면에 **세마포어(Semaphore)**는 좀 더 일반적인 동기화 도구입니다.

세마포어는 내부적으로 정수값(카운터)을 가지고 있으며, 이 값이 0보다 크면 접근 가능하고, 0이면 대기하게 됩니다.
카운터 값을 여러 개로 설정할 수 있기 때문에 동시에 여러 스레드가 접근할 수 있도록 제한할 수도 있습니다.
이런 점에서 보면 뮤텍스는 세마포어의 특수한 형태라고도 할 수 있습니다.

또한, 세마포어는 소유권 개념이 없습니다. 즉, 어떤 스레드가 wait()를 호출하고, 다른 스레드가 signal()을 호출하는 방식도 가능합니다.


## 8.2 이진 세마포어와 뮤텍스의 차이

**한 번에 하나의 스레드만 공유 자원에 접근하도록 제어하는 동기화 도구**라는 점에서 유사하다.
이진 세마포어는 **신호 전달을 통해 스레드 간 동기화**를 할 때 사용하고,
뮤텍스는 **공유 자원의 배타적 보호**가 필요한 임계 구역에서 사용됩니다.

데이터베이스 커넥션 풀이나 스레드풀 같은 구조에서
세마포어나 뮤텍스 같은 개념들이 내부적으로 적용되는 경우를 많이 접하게 되는데요.
이런 동기화 도구를 상황에 맞게 선택하는 것이 성능이나 안정성에 큰 영향을 줄 수 있다고 생각합니다.

## 8.3 Lock 대기 프로세스의 lock 획득 방법
(Lock을 얻기 위해 대기하는 프로세스들은 Spin Lock 기법을 사용할 수 있습니다. 이 방법의 장단점은 무엇인가요? 단점을 해결할 방법은 없을까요?)

락을 얻기 위해 기다리는 동안 컨텍스트 스위칭 없이 루프를 돌며 계속 락을 확인하는 방식을 Spin Lock이라고 합니다.
일반적인 뮤텍스 락은 lock을 못 얻으면 스레드를 sleep 상태로 전환시키는 반면, 스핀 락은 계속 CPU를 점유하면서 대기합니다.

- 장점
    - 락이 **짧은 시간 안에 해제될 것으로 예상될 경우**, 컨텍스트 스위칭 없이 기다릴 수 있어서 오히려 **성능이 더 좋을 수 있습니다.**
    - 특히 **멀티코어 환경에서 락 경쟁이 적고, 락이 금방 해제되는 경우에 적합**합니다.
    - 락을 잡기 위한 과정에서 스레드 상태 전환 비용(context switch)이 없기 때문에, 고성능 시스템에서는 자주 사용됩니다.
- 단점
    - 첫번째로 **CPU 자원 낭비**입니다. 락을 얻을 때까지 연산을 반복하기 때문에 다른 작업들이 CPU를 쓰지 못하게 됩니다.
    - 스레드 우선순위와 상관없는 경쟁 : 모두 동일하게 루프를 돌면서 경쟁
    - 멀티코어 환경에서 캐시 일관성 유지 비용 :  Spin Lock은 계속해서 공유 변수(예: lock 상태)를 읽고 쓰기 때문에 멀티코어 환경에서는 **CPU 간 캐시 일관성을 유지하기 위한 메모리 버스 트래픽**이 증가합니다. 이로 인해 전체 시스템 성능이 저하될 수 있습니다.
- 해결방안
    - **Backoff 전략**
        - 매번 락을 확인하는 게 아니라, **재시도 간의 간격을 점점 늘리면서 락 상태를 확인하는 방식**
    - **Hybrid Lock** 동작 흐름
        1. **락을 시도한다 (try lock)**
        2. 일정 시간 동안 **Spin**한다 (`while` 루프 돌며 lock 상태를 체크)9
        3. 그 시간이 지나도 lock이 안 풀리면, **sleep** 상태로 전환한다 (block, context switch)
        4. **lock을 보유한 스레드가 unlock() 호출**
        5. **block 상태인 스레드 중 하나를 깨워서 다시 lock 시도**
     
## 8.4  뮤텍스와 세마포어 모두 커널이 관리하기 때문에, Lock을 얻고 방출하는 과정에서 시스템 콜을 호출해야 합니다. 이 방법의 장단점이 있을까요? 단점을 해결할 수 있는 방법은 없을까요?

커널이 락을 관리하면 데드락 제어등 안정성과 락 순서 보장등 다중 프로세스 동기화에는 유리하지만,
시스템 콜 오버헤드로 인해 성능 비용이 발생합니다.
이를 보완하기 위한 **Futex 매커니즘**으로 유저 모드에서 먼저 CAS 기반으로 시도한 뒤,  실패 시(충돌 발생 시) 커널 콜을 수행하는 전략이 널리 사용됩니다.
실무에서도 이런 구조는 Java, Linux, JVM 내부 락 구현에서 자주 접할 수 있습니다.


# 9. **Deadlock 에 대해 설명해 주세요.**

## **9.1 Deadlock 에 대해 설명해 주세요.**

Deadlock은 여러 프로세스 자원을 점유한 채 다른 자원을 기다리는 상황에서, 강제로 자원을 회수하지 못하면 서로 대기 상태가 유지되는 상황이다. 

## **9.2 Deadlock이 발생하기 위한 4가지 조건에 대해 설명해 주세요.**

Deadlock이 발생하려면 다음 네 가지 조건이 **모두 충족**되어야 합니다.

1. **상호 배제(Mutual Exclusion)**
    
    → 자원은 하나의 프로세스만 사용할 수 있어야 합니다.
    
2. **점유 대기(Hold and Wait)**
    
    → 프로세스가 자원을 점유한 채로 다른 자원을 기다리는 상태여야 합니다.
    
3. **비선점(No Preemption)**
    
    → 점유한 자원을 강제로 뺏을 수 없어야 합니다.
    비선점은 한 번 어떤 자원을 점유한 프로세스가 **스스로 자원을 반환하기 전까지는**, 운영체제나 다른 프로세스가 그 자원을 **강제로 뺏을 수 없다는 의미**
    
4. **순환 대기(Circular Wait)**
    
    → 프로세스들이 원형으로 자원을 기다리는 형태가 있어야 합니다.
    

## **9.3 그렇다면 3가지만 충족하면 왜 Deadlock은 발생하지 않나요?**

Deadlock은 네 조건이 **동시에** 충족되어야만 발생합니다. 예를 들어 ‘순환 대기’ 조건만 제거하더라도, 사이클이 생기지 않기 때문에 Deadlock은 발생하지 않습니다. 실제로 Deadlock을 예방할 때는 이 중 한 가지 조건이라도 의도적으로 깨트리는 방식으로 해결합니다.

## **9.4 Deadlock은 어떤 방식으로 예방할 수 있을까요?**

- **순환대기 방지 : 자원 할당 순서를 지정**
- **비선점성을 깨뜨리는 방식 :** 타임아웃을 설정(락 기다리는 시간만 제어)하거나, 특정 시간이 지나면 강제 종료(전체 실행 흐름 제어. 예: Thread.interrupt())
- **은행가 알고리즘(Banker’s Algorithm) :** 안전 상태를 유지하면서 자원을 할당
    - 프로세스에게 자원을 할당하기 전에, 지금 자원을 할당해도 시스템이 안전한 상태인지를 계산한 뒤,
    
    안전하다고 판단되면 자원을 할당하는 Deadlock 예방 알고리즘
    

하지만 이런 방법들은 **성능 저하나 구현 복잡도 증가**라는 트레이드오프가 있어서 실무에서는 잘 쓰이진 않습니다.

## **9.5 왜 현대 운영체제는 Deadlock을 처리하지 않나요?**

현대 OS는 대부분 Deadlock을 **감지하거나 회피하지 않고**, 아예 **방치**하는 경우가 많습니다. 이유는 두 가지입니다.

1. **Deadlock 발생 확률이 낮고**
2. **감지·회피 방식이 성능을 크게 저하시킬 수 있기 때문**입니다.

대신에, 일정 시간 동안 응답이 없으면 **Watchdog Timer**나 **타임아웃** 등을 통해 해당 프로세스를 강제 종료시키는 방식으로 대응합니다.

- **Watchdog Timer, 타임아웃(timeout)**

오래 걸리는 작업이나 멈춘 작업을 감지하고 처리하기 위한 장치.
Deadlock을 직접 해결하진 않지만, 무한 대기 상태를 감지하고 시스템을 안정적으로 유지하는 데 사용.

## 9.6 **Wait-Free와 Lock-Free를 비교해 주세요.**

둘 다 동시성 문제를 해결하기 위한 **Non-blocking** 프로그래밍 기법인데요.

- **Lock-Free :**  여러 스레드 중 최소한 하나는 반드시 작업을 마친다는 보장을 합니다
- **Wait-Free :**  모든 스레드가 제한된 시간 안에 작업을 완료한다는, 더 강한 보장입니다.

