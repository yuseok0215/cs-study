
# 1. 시스템 콜이 무엇인지 설명해 주세요.

- https://blog.yevgnenll.me/os/what-is-system-call


## 운영체제 구조

- 운영체제 4가지 구성요소:  **커널**, **인터페이스**, **시스템 콜**, **드라이버**


## 1. 시스템 콜이 무엇인지 설명해 주세요.

- 시스템 콜은 사용자 프로그램이 컴퓨터 자원을 (CPU, 메모리, 디스크 등) 직접 제어할 수 없기 때문에 운영체제를 통해 커널 기능을 사용할 수 있도록 하는 인터페이스 입니다.

.

---

### 2. 우리가 사용하는 시스템 콜의 예시를 들어주세요.

- **파일 I/O** : `open()`, `read()`, `write()`, `close()` 파일 열기, 읽기, 쓰기, 닫기
- 프로세스 생성과 제어 : `fork()`, `exec()`, `wait()`  프로세스 생성, 새 프로그램 실행, 프로세스 종료
- 네트워크 통신: `socket()`, `connect()`, `bind()`  소켓 생성, 연결 요청, 연결 수락
- 예: Java에서도 `FileInputStream`을 열면 내부적으로는 `open()` 시스템 콜을 사용합니다.

---

### 3. 시스템 콜이 운영체제에서 어떤 과정으로 실행되는지 설명해 주세요.

- [https://daehee-backend.tistory.com/entry/시스템-콜이란](https://daehee-backend.tistory.com/entry/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C%EC%9D%B4%EB%9E%80)
1. 유저모드(User Mode)에서 애플리케이션이 시스템 콜 라이브러리 호출
2. 시스템 콜 번호를 레지스터에 저장
3. 커널에 제어권 전달 : CPU가 커널모드(Kernel Mode)로 전환
    - `trap` 또는 **소프트웨어 인터럽트**(int 0x80) 명령으로 커널에 제어권 전달
    - 인터럽트(interrupt) 가 발생하여 CPU의 제어를 운영체제로 넘긴다.
4.  커널이 시스템 콜 번호에 맞는 루틴 실행
5. 처리 결과를 레지스터에 담아 유저모드로 복귀

---

### 4. 시스템 콜의 유형에 대해 설명해 주세요.

시스템 콜은 보통 다음과 같이 분류됩니다:

| 유형 | 설명 |
| --- | --- |
| 프로세스 제어 | `fork()`, `exec()`, `exit()`, `wait()` |
| 파일 조작 | `open()`, `read()`, `write()`, `close()` |
| 장치 조작 | I/O 디바이스 접근 (`ioctl()`, `read()` 등) |
| 정보 유지 | `getpid()`, `alarm()`, `sleep()` 등 |
| 통신 | `socket()`, `bind()`, `connect()`, `send()` |

---

### 5. 운영체제의 Dual Mode에 대해 설명해 주세요.

Dual Mode(이중 모드)는 CPU가 동작할 수 있는 두 가지 모드로, 사용자모드와 커널 모드가 있다. CPU는 시스템 콜이나 인터럽트 발생 시 User → Kernel Mode로 전환됩니다.

- **User Mode (사용자 모드)**: 사용자 애플리케이션 코드가 실행되는 모드로, 제한된 권한. 시스템 자원 접근 불가.
- **Kernel Mode (커널 모드)**: 운영체제가 CPU를 사용하는 모드로, 모든 자원 접근 가능. OS의 핵심 기능 실행.

---

### 6. 왜 유저모드와 커널모드를 구분해야 하나요?

- **보안**: 일반 애플리케이션이 임의로 메모리나 디바이스에 접근하면 시스템이 불안정해질 수 있습니다.
- **안정성**: 하나의 유저 프로그램 오류로 전체 OS가 망가지지 않게 보호
- **권한 분리**: 커널이 중요한 자원을 안전하게 관리할 수 있도록

---

### 7. 서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?

커널은 시스템 콜을 구분하기 위해 시스템 콜에 고유번호를 할당하고 그 번호에 해당하는 제어 루틴을 커널 내부에 정의한다.

시스템 콜을 호출하면 이 번호를 레지스터에 저장하고 커널에 전달하며, 커널은 이 번호를 기준으로 해당 함수로 분기합니다.

예시:`eax` 레지스터의 값이 시스템 콜 번호입니다.

```c
mov eax, 1     ; write()
mov ebx, 1     ; stdout
mov ecx, msg
mov edx, len
int 0x80       ; 시스템 콜 인터럽트
```

---

## 2. 인터럽트가 무엇인지 설명해 주세요.

인터럽트는 CPU가 어떤 작업을 수행 중일 때, 외부나 내부에서 발생한 사건을 즉시 처리하기 위해 실행 흐름을 잠시 멈추고 **커널에게 제어권을 넘기는 메커니즘**입니다.

예를 들어 키보드를 누르거나 네트워크 패킷이 도착하면, CPU는 그 입력을 즉시 처리하기 위해 현재 작업을 중단하고 인터럽트 처리 루틴으로 흐름을 전환합니다.

- **이벤트 기반 처리**로, 리소스를 낭비하지 않고 효율적으로 작업할 수 있습니다.

---

### 🔁 Polling 방식에 대해 설명해 주세요.

Polling은 인터럽트와 반대되는 방식인데요, 디바이스의 상태를 CPU가 계속 확인하면서 "데이터 왔는지"를 반복적으로 체크하는 방식입니다.

이 방식은 구현이 간단하다는 장점은 있지만, 디바이스에서 아무 작업이 없더라도 CPU가 디바이스를 계속 체크하기 때문에 CPU 자원이 낭비되는 단점이 있습니다.

그래서 대부분의 운영체제는 효율성을 위해 인터럽트 방식을 사용합니다.

**Polling**은 CPU가 주기적으로 디바이스(예: 마우스, 키보드 등)를 **계속 확인하며 상태를 체크**하는 방식입니다.

- 예시: “데이터 왔나?”, “왔나?”, “아직도?”
- 단점: CPU가 유휴 상태일지라도 계속 확인하므로 **비효율적**입니다.
- 인터럽트는 이 Polling의 단점을 해결하기 위한 방식입니다.

---

### ⚙️ 인터럽트는 어떻게 처리하나요?

인터럽트가 발생하면, CPU는 먼저 현재 작업의 상태를 저장하고 커널 모드로 전환됩니다.

그다음, 인터럽트 번호를 기반으로 운영체제가 미리 정의해둔 인터럽트 처리 함수, 즉 ISR(Interrupt Service Routine)을 실행합니다.

이 처리가 끝나면 다시 저장해둔 작업으로 복귀해서 원래 작업을 이어갑니다.

1. 디바이스 또는 프로그램에서 인터럽트 요청 발생 (IRQ, system call 등)
2. CPU는 현재 작업을 저장하고(문맥 저장, Context Save)
3. 인터럽트 벡터 테이블(IVT)을 통해 해당 인터럽트에 맞는 ISR (Interrupt Service Routine)으로 이동
4. ISR 수행 후, 저장해두었던 작업으로 복귀 (문맥 복원, Context Restore)

> 유저모드 → 커널모드 전환이 일어나며, 이 과정은 시스템 콜 처리와도 유사합니다.
> 

---

### 🔌 **하드웨어 인터럽트와 소프트웨어 인터럽트의 차이를 설명해 주세요.**

**하드웨어 인터럽트**는 키보드, 마우스, 네트워크 카드 같은 **외부 장치**에서 발생합니다. 예를 들어, 사용자가 키보드를 누르면 바로 인터럽트가 발생해 입력을 처리하게 됩니다.

반면 **소프트웨어 인터럽트**는 프로그램 내부에서 명령어를 통해 발생시키는 인터럽트입니다. 대표적인 예로는 시스템 콜이 있습니다. 시스템 콜은 프로그램이 운영체제의 기능을 요청할 때 사용하는 일종의 소프트웨어 인터럽트입니다.

| 구분 | 하드웨어 인터럽트 (HW) | 소프트웨어 인터럽트 (SW) |
| --- | --- | --- |
| 발생 주체 | 외부 장치 (키보드, 마우스, 타이머 등) | 프로그램 내부 코드 (`int`, `syscall` 등) |
| 예시 | 타이머 인터럽트, 네트워크 패킷 수신 등 | 시스템 콜, 예외(Exception) 처리 |
| 처리 목적 | 외부 이벤트 반응 | 운영체제 기능 요청, 예외 처리 |

---

### ⏱ 동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요?

운영체제는 보통 인터럽트마다 우선순위를 설정해서 더 중요한 인터럽트를 먼저 처리합니다.

예를 들어, 타이머 인터럽트가 가장 우선순위가 높고, 그 다음이 키보드 입력, 그 다음이 일반 디바이스일 수 있습니다.

만약 높은 우선순위의 인터럽트가 처리 중에 또 발생하면, 현재 인터럽트를 잠시 멈추고 더 중요한 인터럽트를 먼저 처리한 뒤 다시 돌아오는 방식으로 처리합니다.

또한 일부 인터럽트는 마스킹 설정을 통해 일시적으로 무시할 수도 있습니다.

운영체제와 CPU는 **우선순위(priority)**와 **인터럽트 마스킹(interrupt masking)** 기법을 통해 처리 순서를 결정합니다.

1. **우선순위 기반 처리**
    - 타이머 인터럽트 > 키보드 입력 > 기타 디바이스 등
2. **Nested Interrupt (중첩 인터럽트)**
    - 우선순위가 높은 인터럽트가 들어오면, 현재 인터럽트를 잠시 멈추고 높은 우선순위의 ISR 실행
3. **마스킹(Masking)**
    - 특정 인터럽트를 일시적으로 무시하거나 차단할 수도 있음

💡 이런 방식을 통해 시스템이 **동시성 문제 없이** 안정적으로 이벤트를 처리할 수 있습니다.

---

### 🎯 정리 요약

| 질문 | 키워드 요약 |
| --- | --- |
| 인터럽트란? | 작업 중단 → 우선 이벤트 처리 |
| Polling vs Interrupt | 계속 확인 vs 이벤트 기반 처리 |
| HW/SW 인터럽트 차이 | 외부 장치 vs 내부 명령어 |
| 인터럽트 처리 순서 | 우선순위 → Context Save → ISR 실행 |
| 동시 발생 시 처리 방법 | 우선순위 판단, 마스킹, 중첩 처리 |

---

# **3. 프로세스가 무엇인가요?**

프로세스는 실행 중인 프로그램을 의미합니다.

하드디스크에 저장된 정적인 프로그램 파일이 메모리에 적재되어 CPU에서 실행될 때, 이를 운영체제가 하나의 단위로 관리하는 것이 프로세스입니다. (하드디스크에 있는 정적인 프로그램 파일이 메모리에 적재되고, 운영체제가 CPU 시간과 메모리 같은 자원을 할당해 실행되는 단위를 말합니다.)

운영체제는 각각의 프로세스를 독립된 존재로 취급하며, 고유한 메모리 공간과 자원, 상태 정보를 관리합니다.

프로세스는 foreground process(눈에 보이는 프로세스) 와 background process(눈에 보이지 않은 프로세스) 로 구분된다.

---

**Q. 프로그램, 프로세스, 스레드의 차이를 설명해 주세요.**

간단하게 말하자면:

- **프로그램**은 실행되지 않은 정적인 코드입니다. 예: `.jar`, `.exe`
- **프로세스**는 이 프로그램이 실행되면서 운영체제가 메모리와 자원을 할당한 실행 단위입니다.
- **스레드**는 프로세스 내에서 실제로 실행 흐름을 담당하는 최소 단위입니다.

하나의 프로세스는 여러 개의 스레드를 가질 수 있고, 이 스레드들은 **프로세스의 메모리 공간을 공유**하며 실행됩니다.

---

**Q. PCB가 무엇인가요?**

PCB는 Process Control Block의 약자로, 운영체제가 프로세스를 관리하기 위해 사용하는 자료구조입니다. 각 프로세스는 PCB를 가지고 있습니다. 

여기에는 프로세스의 상태, PID, 레지스터 정보, 메모리 위치, 스케줄링 정보 등 다양한 정보가 저장되어 있어요.

운영체제는 PCB를 통해 각 프로세스를 추적하고 상태를 관리합니다.



---

**Q. 그렇다면, 스레드는 PCB를 갖고 있을까요?**

스레드는 PCB 자체는 갖고 있지 않습니다. 대신, **프로세스의 PCB를 공유**하면서 자신의 실행 정보를 따로 가지고 있는 TCB(Thread Control Block)를 가집니다.

TCB에는 스레드의 ID, 상태, 스택 포인터, 레지스터 등의 정보가 포함됩니다.

즉, 여러 스레드가 하나의 PCB를 공유하며 실행 흐름만 다르게 가져가는 구조입니다.

---

**Q. 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성되나요?**

리눅스에서 프로세스는 `fork()` 시스템 콜을 통해 생성됩니다.

이는 현재 프로세스를 복제해서 자식 프로세스를 만들고, 이후 `exec()`를 통해 다른 프로그램으로 실행을 전환할 수 있습니다.

스레드는 `pthread_create()` 또는 내부적으로는 `clone()` 시스템 콜을 통해 생성되며, 이때 메모리 공간을 공유하게 됩니다. 참고로 clone은 메모리 공간이나 파일 디스크립터 등을 공유할지를 세밀하게 지정할 수 있습니다.

특히 리눅스에서는 스레드도 내부적으로는 일종의 프로세스처럼 관리되며, **CLONE** 플래그를 통해 어느 정도를 공유할지 설정할 수 있습니다.

- 프로세스 : for() , 현재 프로세스 복제해 자식 프로세스 생성
- 스레드 : clone(), 메모리 공간 공유. 리눅스에서는 일종의 프로세스처럼 관리됨. (CLON 플래그 : 어느 정도 공유 설정)

---

**Q. 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?**

- 부모 프로세스가 먼저 죽고 자식 프로세스가 남아 있는 경우, 해당 자식은 고아 프로세스(orphan)가 됩니다.
    - 이 경우, init 프로세스(또는 systemd)가 고아 프로세스를 자동으로 **입양하여 관리**하게 됩니다.
- 반대로, 자식 프로세스가 먼저 종료되었는데 부모가 이를 수거하지 않으면, 자식은 좀비 프로세스(zombie)가 됩니다.
    - 이때 부모 프로세스가 `wait()` 또는 `waitpid()`를 호출해 자식의 종료 상태를 수거하지 않으면 좀비 상태가 유지됩니다.

---

**Q. 리눅스에서 데몬 프로세스란 무엇인가요?**

데몬은 백그라운드에서 실행되는 프로그램으로, 사용자가 직접적으로 제어하지 않고 백그라운드에서 돌면서 여러 작업을 하는 프로그램을 말한다. 사용자의 요청을 기다리고 있다가 요청이 발생하면 이에 적절히 대응하는 리스너와 같은 역할을 한다. 즉, 메모리에 상주하면서 특정 요청이 오면 즉시 대응 할 수 있도록 대기중인 프로세스를 말한다. 

데몬은 항상 돌아가고 있어야하는 웹서버에 적합하여 일반적으로 서버에서 주로 사용된다. 대표적인 예로 Apache 웹서버의 httpd가 바로 데몬 프로그램이다. httpd는 웹서버에 백그라운드에서 실행되면서 서버로 들어오는 요청에 자동으로 응답해 준다.

이밖에도 유닉스(리눅스) 운영체제에서 운영체제에서 프로세스 이름 끝이 d로 끝나는 프로세스들이 대표적인데 inetd, httpd, nfsd, sshd, named, lpd 등이 있다.

백그라운드 프로세스와 마찬가지로 TTY(터미널 장치)를 가지고 있지 않으며,

 PPID(parent id)가 1이고, 

SID(session id) 역시 자신의 아이디와 같다는 특징이 있습니다.

데몬이 백그라운드에서 계속 실행되고 있다는 것은 요청이 오면 즉시 대응할 수 있도록 대기 중이다. 

데몬이 실행되는 방식은 **'Stand alond', 'Xinetd'** 두 가지입니다.

- **Stand alone**

데몬이 독자적으로 구동되는 방식으로 혼자서 요청을 받아 처리합니다. 메모리에 상주하며 항상 구동되고 있기 때문에 요청에 대한 응답 속도가 빨라서 요청이 빈번하게 일어나는 프로세스에 많이 사용됩니다.

속도는 빠르지만 메모리에 계속 상주하며 구동되고 있기 때문에 부하를 줄 수 있다는 점은 알아두어야 하는 부분입니다.

ex) sendmail, apache, mysqld 등이 있습니다.

- **Xinetd**

다른 데몬들의 상위에 존재하며, 슈퍼 데몬(Super Daemon)이라고도 불립니다.

요청이 왔을 때 자신(xinetd)에게 종속된 하위 데몬을 실행시키는 방식이지만, xinetd 자체는 stand alone 방식으로 동작합니다.

하위 데몬의 기준으로 본다면 응답 처리 속도는 위 stand alone 방식에 비해서 느리지만, 요청이 들어오지 않을 때는 휴면 상태가 되어 메모리를 사용하지 않는다는 장점이 있으며, 요청이 빈번하지 않은 서비스에서 사용됩니다.

ex) telnet, finger, ftp, shell 등이 있습니다.

- https://wildeveloperetrain.tistory.com/168
- [https://won21yuk.github.io/posts/용어정리-데몬(Daemon)-프로세스/](https://won21yuk.github.io/posts/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC-%EB%8D%B0%EB%AA%AC(Daemon)-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/)
- [https://inpa.tistory.com/entry/프로세스-데몬-서비스-정리](https://inpa.tistory.com/entry/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8D%B0%EB%AA%AC-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%A0%95%EB%A6%AC)

데몬 프로세스는 **백그라운드에서 실행되는 프로세스**로, 일반적으로 사용자의 직접적인 입력 없이 시스템 기능을 수행합니다.

예를 들어, 웹 서버의 `nginx`, 스케줄링을 담당하는 `cron`, 로그 수집기 등은 전형적인 데몬 프로세스입니다.

데몬은 보통 부모 프로세스에서 `fork()` → `setsid()` → `chdir("/")` → `umask(0)` → 표준 입출력 close 등의 절차를 거쳐 독립적인 환경에서 실행됩니다.

---

**Q. 리눅스에서 프로세스 트리의 루트에 위치한 프로세스는 무엇인가요?**

- https://process-mining.tistory.com/19

리눅스에서는 모든 프로세스가 부모-자식 구조로 연결된 트리를 형성하며, 그 루트에 위치한 프로세스가 바로 `init` 프로세스입니다.

시스템이 부팅될 때 가장 먼저 실행되며, 프로세스 번호는 항상 `PID 1`입니다.

이 프로세스는 모든 고아 프로세스를 수거하고, 시스템 전체의 서비스 관리도 담당합니다. 최신 리눅스에서는 `systemd`가 init의 역할을 대체하고 있습니다.
